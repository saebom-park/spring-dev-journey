# Day06 – 교착상태 (Questions)

# 1. 기본 질문 (Basic)
---

### **Q1. 교착상태(Deadlock)란 무엇인가요?**
**A.**  
“교착상태는 두 개 이상의 프로세스나 스레드가  
서로가 가진 자원을 기다리면서  
실행이 영원히 진행되지 않는 상태를 말합니다.  
서로 ‘너 먼저 해’라고 기다리는 상황이어서  
아무도 앞으로 나아가지 못하게 되고,  
CPU는 한가한데 프로그램은 멈춘 것처럼 보이는 것이 특징입니다.”

---

### **Q2. 교착상태 발생 조건 4가지(Coffman 조건)를 설명해주세요.**
**A.**  
“교착상태는 다음 네 가지 조건이 모두 만족할 때 발생합니다.

1) **상호 배제(Mutual Exclusion)** – 자원은 한 번에 한 프로세스만 사용 가능  
2) **점유와 대기(Hold and Wait)** – 자원을 가진 상태에서 추가 자원을 요청하며 대기  
3) **비선점(Non-preemption)** – 자원을 강제로 빼앗을 수 없음  
4) **순환 대기(Circular Wait)** – 서로가 서로의 자원을 기다리는 고리 관계

이 네 가지 중 하나라도 깨트릴 수 있으면 교착상태는 발생하지 않습니다.”

---

### **Q3. 교착상태와 기아(Starvation)의 차이는 무엇인가요?**
**A.**  
“교착상태는 여러 프로세스가 서로 영원히 기다리면서  
전체 흐름이 멈춰버리는 상태이고,  
기아는 우선순위가 낮은 프로세스가 실행 기회를 계속 얻지 못하는 상태입니다.  

즉, 교착상태는 ‘전체가 멈추는 문제’,  
기아는 ‘특정 작업만 굶는 문제’라고 정리할 수 있습니다.”

---

# 2. 중급 질문 (Intermediate)
---

### **Q4. 교착상태 예방(Prevention) 기법을 설명해주세요.**
**A.**  
“예방 기법은 교착상태 발생 조건 4가지 중  
하나 이상을 아예 성립하지 못하게 만드는 방법입니다.  

예를 들어 락을 항상 A → B 순서로 획득하게 만들어  
‘순환 대기’를 절대 만들지 않게 하면  
교착상태는 원천적으로 발생하지 않습니다.  
다만 너무 보수적으로 자원을 제한해야 해서  
성능이 떨어지는 단점이 있습니다.”

---

### **Q5. 교착상태 회피(Avoidance)란 무엇인가요?**
**A.**  
“회피는 ‘모든 요청을 무조건 거절하는 것’이 아니라  
‘지금 이 요청을 허용하면 시스템이 안전 상태(Safe State)를 유지할 수 있는가’를 판단해서  
위험할 때만 잠시 대기시키는 방식입니다.  

대표적인 회피 기법이 은행원 알고리즘인데,  
요청을 허용했을 때 모든 프로세스가 결국 완료될 수 있으면 허용하고,  
그렇지 않으면 잠시 보류하여 위험을 피합니다.”

---

### **Q6. 교착상태 탐지와 복구는 언제 필요하나요?**
**A.**  
“예방이나 회피가 현실적으로 어렵거나  
성능을 위해 어느 정도 위험을 감수해야 하는 시스템에서는  
‘교착상태를 허용하되, 발생하면 해결’하는 전략을 사용합니다.  

OS나 DBMS는 주기적으로 자원 그래프를 분석해  
교착상태 여부를 검사하고,  
문제가 감지되면 특정 프로세스를 종료하거나  
트랜잭션을 강제 롤백시키는 방식으로 복구합니다.”

---

# 3. 심화 질문 (Advanced)
---

### **Q7. 순환 대기(Circular Wait)는 왜 그렇게 중요한 조건인가요?**
**A.**  
“순환 대기는 교착상태의 본질이라고 할 수 있습니다.  
자원의 의존 관계가 고리처럼 연결되어 있어야  
서로가 서로를 기다리는 상황이 만들어지기 때문입니다.  

이 고리 구조만 없애면  
나머지 조건이 성립해도 교착상태가 발생할 수 없기 때문에  
실무에서는 ‘락 획득 순서를 통일하는 방식’이  
가장 효과적인 교착상태 예방 기법으로 사용됩니다.”

---

### **Q8. 은행원 알고리즘이 실무에서는 잘 쓰이지 않는 이유는 무엇인가요?**
**A.**  
“은행원 알고리즘은 이상적인 모델이지만  
실무에서는 자원 수요가 동적으로 변하고  
프로세스 수, 요청량이 너무 다양하기 때문에  
‘안전 상태 검사’가 사실상 불가능할 때가 많습니다.  

또한 계산 비용이 크고,  
지나치게 보수적으로 동작하면 성능이 크게 떨어지기 때문에  
대규모 서버 환경에서는  
락 순서 통일, 타임아웃 기반 회피 등이 더 현실적인 해결책입니다.”

---

# 4. 꼬리질문 (Follow-up)
---

### **Q9. 교착상태를 예방하기 위해 “락 획득 순서 통일”을 실무에서 어떻게 적용하나요?**
**A.**  
“예를 들어 두 개의 공유 자원 A와 B를 사용하는 코드가 있다면  
모든 스레드가 항상 A → B 순서로만 락을 획득하도록 규칙을 강제합니다.  

이렇게 하면 순환 대기 구조가 절대 생길 수 없기 때문에  
교착상태를 근본적으로 차단할 수 있습니다.  
실무 팀에서는 ‘락 규칙 문서’를 만들어 아예 강제하는 경우도 많습니다.”

---

### **Q10. 교착상태를 확실히 감지하는 방법은 무엇인가요?**
**A.**  
“운영 중인 서버에서는 스레드 덤프나 DB 락 모니터링을 활용합니다.  
스레드 덤프에서 특정 스레드가 어떤 락을 기다리고 있고  
그 락을 어떤 스레드가 가지고 있는지  
고리 구조가 보이면 교착상태입니다.  

DB(InnoDB)는 자체적으로 `lock wait timeout`, `deadlock found` 같은 메시지를 통해  
교착상태를 자동으로 탐지하고  
피해가 적은 트랜잭션을 강제로 롤백하여 복구합니다.”

---

# 5. 실무 질문 (Practical)
---

### **Q11. 데드락이 발생했을 때 가장 먼저 확인해야 할 것은 무엇인가요?**
**A.**  
“CPU나 메모리보다 먼저  
‘어떤 락을 어떤 순서로 획득하려 했는가’를 봅니다.  
스레드 덤프 또는 DB 락 대기 목록을 보면  
서로가 서로의 자원을 기다리고 있는 패턴이 바로 드러납니다.  
그 후 락 순서를 일관되게 수정하거나  
트랜잭션 범위를 줄이는 방향으로 해결합니다.”

---

### **Q12. 교착상태와 스레드 블로킹은 어떤 차이가 있나요?**
**A.**  
“스레드 블로킹은 잠시 자원을 기다리는 정상적인 상황이지만,  
교착상태는 서로가 서로를 기다리면서 절대 풀리지 않는 비정상적인 상태입니다.  
즉 시간 문제로 해결되는 것은 블로킹이고,  
시간이 지나도 절대 해결되지 않는 것이 교착상태입니다.”

---

# 6. 비교 질문 (Comparison)
---

### **Q13. 교착상태 vs 라이브락(Livelock)의 차이를 설명해주세요.**
**A.**  
“교착상태는 서로 기다리느라 멈춰버리는 상태이고,  
라이브락은 서로 피해주려고 계속 움직이지만  
실제로는 아무 진전이 없는 상태입니다.  
즉 교착상태는 ‘멈춤’, 라이브락은 ‘바쁘지만 제자리걸음’이라고 보면 됩니다.”
