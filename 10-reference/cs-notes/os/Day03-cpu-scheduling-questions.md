# Day03 – CPU 스케줄링 (Questions)

# 1. 기본 질문 (Basic)
---

### **Q1. CPU 스케줄링이란 무엇인가요?**
**A.**  
“CPU 스케줄링은 ‘준비된 작업들 중에서 누구를 먼저 CPU에 올릴지’를 결정하는 운영체제의 정책입니다.  
프로세스나 스레드는 동시에 실행되고 싶어 하지만, 실제로 CPU는 한 순간에 하나만 실행할 수 있기 때문에  
운영체제가 순서를 정해줘야 합니다.  
이때 어떤 기준으로 순서를 정하느냐에 따라 평균 대기 시간, 응답 시간, 처리량이 크게 달라지기 때문에  
CPU 스케줄링은 성능과 직결되는 핵심 개념이라고 볼 수 있습니다.”

---

### **Q2. FCFS 스케줄링을 설명해주세요.**
**A.**  
“FCFS는 ‘First Come, First Served’라는 이름 그대로, 먼저 도착한 작업을 먼저 처리하는 방식입니다.  
Ready Queue에 들어온 순서대로 CPU를 할당해 주기 때문에 구현이 단순하고 직관적이라는 장점이 있습니다.  
다만 긴 작업이 앞에 오면 뒤에 있는 짧은 작업들이 줄줄이 기다리게 되는 Convoy Effect가 발생할 수 있습니다.  
그래서 공정해 보이긴 하지만 성능 면에서는 항상 좋은 선택은 아니고,  
주로 단순한 배치 작업이나 순서 보장이 중요한 시스템에서 쓰이는 편입니다.”

---

### **Q3. SJF 스케줄링이 무엇이고, 왜 평균 대기 시간이 가장 짧은가요?**
**A.**  
“SJF는 ‘Shortest Job First’의 약자로, CPU를 짧게 사용하는 작업부터 먼저 실행하는 알고리즘입니다.  
줄 서 있는 손님 중에서 계산이 가장 빨리 끝날 것 같은 사람부터 처리하는 것과 비슷한데,  
이렇게 하면 긴 작업 하나가 줄을 막고 있는 상황을 피할 수 있기 때문에 평균 대기 시간이 가장 짧아집니다.  
다만 실제 시스템에서는 각 작업이 앞으로 정확히 얼마나 CPU를 쓸지 알 수 없기 때문에  
과거 기록을 기반으로 예측 값을 사용하는 식으로 근사해서 적용하는 경우가 많습니다.”

---

# 2. 중급 질문 (Intermediate)
---

### **Q4. Priority 스케줄링의 장점과 문제점을 설명해주세요.**
**A.**  
“Priority 스케줄링은 각 프로세스에 우선순위를 매기고,  
우선순위가 높은 작업부터 CPU를 할당하는 방식입니다.  
시스템 프로세스나 긴급한 작업에 높은 우선순위를 줄 수 있어서,  
중요도 기반으로 자원을 배분하고 싶을 때 유용합니다.  

하지만 우선순위가 낮은 작업은 계속 뒤로 밀리다가  
아예 실행 기회를 거의 얻지 못하는 기아(starvation) 문제가 발생할 수 있습니다.  
이를 완화하기 위해 오래 기다린 작업의 우선순위를 조금씩 올려주는 Aging 같은 기법을 함께 사용하는 것이 일반적입니다.”

---

### **Q5. Round Robin 스케줄링의 핵심 개념과 특징은 무엇인가요?**
**A.**  
“Round Robin은 각 작업에게 정해진 시간 조각, 즉 time slice를 주고  
그 시간 동안만 CPU를 쓰게 한 다음, 시간이 지나면 강제로 CPU를 회수해서  
다음 작업에게 넘겨주는 방식입니다.  
이렇게 하면 모든 작업이 CPU를 조금씩 공평하게 나눠 쓰기 때문에  
특정 작업이 CPU를 독점하는 상황을 막을 수 있고,  
응답 속도가 중요한 인터랙티브 시스템이나 서버에서 많이 사용됩니다.  

다만 time slice가 너무 짧으면 컨텍스트 스위칭이 너무 자주 일어나서 오버헤드가 커지고,  
너무 길면 사실상 FCFS와 비슷해지면서 응답성이 떨어집니다.  
그래서 서비스 특성에 맞는 적절한 time slice를 설정하는 것이 중요합니다.”

---

# 3. 심화 질문 (Advanced)
---

### **Q6. Convoy Effect란 무엇이며, 어떤 상황에서 발생하나요?**
**A.**  
“Convoy Effect는 긴 작업 하나가 앞에서 CPU를 오랫동안 붙잡고 있는 바람에  
뒤에 있는 짧은 작업들이 줄줄이 기다리게 되는 현상을 말합니다.  
대표적으로 비선점형 FCFS에서 자주 등장하는 문제인데,  
CPU burst가 큰 작업이 맨 앞에 있다 보니 전체 시스템의 응답성이 급격히 나빠지고  
평균 대기 시간도 늘어나는 결과를 초래합니다.  

실제 서버에서도 CPU를 오래 점유하는 배치 작업이  
웹 요청 처리 스레드보다 우선 실행되면 비슷한 현상을 겪게 되는데,  
이때는 스케줄링 정책 조정이나 배치 작업 분리 같은 방식으로 구조를 다시 잡아줘야 합니다.”

---

### **Q7. SJF/SRTF 스케줄링의 한계는 무엇인가요?**
**A.**  
“SJF와 SRTF는 이론적으로 평균 대기 시간이 가장 짧은 아주 효율적인 알고리즘입니다.  
하지만 치명적인 한계는 ‘앞으로 이 작업이 얼마나 CPU를 사용할지’에 대한 정보를  
정확히 알고 있어야 한다는 점입니다.  

실제 시스템에서는 이런 정보를 알기 어렵기 때문에  
보통 과거 실행 기록을 바탕으로 CPU burst를 예측하거나,  
작업의 특성에 따라 대략적인 추정 값을 사용하는 방식으로 근사합니다.  
그래서 SJF는 실무에서 ‘그대로 쓰는 알고리즘’이라기보다,  
스케줄링 설계 시 참고하는 이상적인 기준에 가깝다고 볼 수 있습니다.”

---

# 4. 꼬리질문 (Follow-up)
---

### **Q8. Round Robin에서 time slice는 어떻게 정하는 게 좋나요?**
**A.**  
“time slice를 정할 때는 ‘응답 시간 vs 오버헤드’의 균형을 보는 것이 핵심입니다.  
너무 짧으면 작업들이 자주 교체되면서 context switching 비용이 폭발하고,  
너무 길면 한 작업이 CPU를 독점하는 시간이 길어져서 사용자 입장에서 응답이 느려집니다.  

그래서 보통은 시스템의 평균 작업 길이,  
컨텍스트 스위칭 비용, 요구되는 응답 시간 등을 고려해 적정 값을 찾습니다.  
실무에서는 OS 기본 설정을 기준으로 시작해서,  
부하 테스트 결과를 보면서 조금씩 조정하는 방식으로 튜닝하는 경우가 많습니다.”

---

### **Q9. Priority 스케줄링에서 기아(starvation)를 막기 위한 Aging 기법을 설명해주세요.**
**A.**  
“Aging은 오랫동안 기다리는 작업의 우선순위를  
시간이 지날수록 조금씩 올려주는 기법입니다.  
처음에는 우선순위가 낮아서 계속 밀리던 작업도  
대기 시간이 길어질수록 우선순위가 올라가고,  
결국 어느 순간에는 높은 우선순위 작업보다 앞서서 실행될 수 있게 만드는 방식입니다.  

이렇게 하면 중요도가 높은 작업을 우선 처리하는 장점을 유지하면서도,  
우선순위가 낮다는 이유만으로 작업이 영원히 실행되지 않는 기아 문제를  
상당 부분 완화할 수 있습니다.”

---

# 5. 실무 질문 (Practical)
---

### **Q10. 서버 CPU가 100%일 때, 스케줄링 관점에서 어떤 것들을 확인하시나요?**
**A.**  
“저라면 우선 단순히 ‘CPU가 100%다’에서 멈추지 않고,  
스케줄링 관점에서 몇 가지 지표를 같이 봅니다.  
대표적으로 Run Queue 길이, context switching 횟수,  
스레드 풀 상태(활성 스레드 수, 대기 중인 작업 수) 같은 것들을 확인합니다.  

Run Queue가 길게 유지되고 있다면 CPU를 쓰고 싶어 하는 작업이 계속 밀리고 있다는 뜻이고,  
context switching이 지나치게 많다면 스레드 수가 과도하거나  
time slice, 락 경쟁 등의 문제가 있을 수 있습니다.  
이런 지표들을 함께 보면 ‘단순히 연산량이 많은 상황인지’,  
‘스레드 구조 설계가 잘못된 건지’를 구분하는 데 도움이 됩니다.”

---

### **Q11. 웹 서버에서 Round Robin 방식이 유용한 이유는 무엇인가요?**
**A.**  
“웹 서버는 다양한 요청이 섞여 들어오고,  
특정 요청이 오래 걸린다고 해서 나머지 요청을 계속 기다리게 만들고 싶지는 않습니다.  
Round Robin은 모든 요청을 조금씩 번갈아 처리하기 때문에  
특정 요청이 CPU를 계속 독점하는 상황을 줄여 주고,  
전체적으로 짧은 응답 시간을 유지하는 데 유리합니다.  

실제 구현은 OS 레벨 스케줄러와 서버 내부 스레드 풀이 함께 맞물려 돌아가지만,  
기본 아이디어는 ‘모든 요청에게 CPU를 골고루 나눠준다’는 부분이라  
웹 서버처럼 응답성이 중요한 환경과 잘 어울립니다.”

---

# 6. 비교 질문 (Comparison)
---

### **Q12. FCFS와 Round Robin의 차이를 설명해주세요.**
**A.**  
“두 알고리즘 모두 ‘줄을 서서 CPU를 기다린다’는 점은 같지만,  
FCFS는 한 번 CPU를 잡으면 작업이 끝나거나 I/O로 빠질 때까지 계속 사용하는 반면,  
Round Robin은 정해진 시간(time slice)만큼만 사용하도록 강제로 제한합니다.  

그래서 FCFS에서는 앞에 긴 작업이 오면 뒤에 있는 짧은 작업들이 계속 기다리게 되고,  
Round Robin에서는 긴 작업이라도 조금씩 나눠서 실행되기 때문에  
뒤에 온 작업들도 빠르게 CPU를 맛볼 수 있습니다.  
결과적으로 Round Robin이 응답 시간 측면에서 훨씬 유리하고,  
인터랙티브 환경이나 서버 환경에 더 잘 맞는 편입니다.”

---

### **Q13. SJF와 Priority 스케줄링의 차이를 설명해주세요.**
**A.**  
“SJF와 Priority 스케줄링은 ‘어떤 기준으로 먼저 실행할지를 정하느냐’에서 차이가 납니다.  
SJF는 앞으로 사용할 CPU 시간, 즉 작업 길이를 기준으로 짧은 작업을 먼저 실행하는 알고리즘이고,  
Priority 스케줄링은 업무 중요도나 시스템 정책에 따라 매긴 우선순위 값을 기준으로 실행 순서를 결정합니다.  

즉, SJF는 ‘얼마나 빨리 끝날 것 같으냐’를 보고 순서를 정하는 알고리즘이고,  
Priority는 ‘얼마나 중요한 작업이냐’를 보고 순서를 정하는 알고리즘이라고 정리할 수 있습니다.  
실무에서는 둘 중 하나만 쓰기보다는,  
우선순위 시스템 안에서 예상 처리 시간까지 고려하는 식으로  
여러 개념을 섞어서 사용하는 경우가 많습니다.”
