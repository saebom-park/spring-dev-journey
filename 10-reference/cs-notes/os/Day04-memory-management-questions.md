# Day04 – 메모리 관리 (Questions)

# 1. 기본 질문 (Basic)
---

### **Q1. 페이징과 세그멘테이션의 차이를 설명해주세요.**
**A.**  
“페이징은 메모리를 **동일한 크기의 페이지 단위로 나누는 방식**이고,  
세그멘테이션은 프로그램을 **의미 있는 논리 단위(코드, 데이터, 스택 등)**로 나누는 방식입니다.  

페이징은 외부 단편화를 해결하지만 내부 단편화가 발생할 수 있고,  
세그멘테이션은 구조적으로 의미 있지만 외부 단편화가 생길 수 있다는 차이가 있습니다.”

---

### **Q2. 외부 단편화와 내부 단편화의 차이는 무엇인가요?**
**A.**  
“외부 단편화는 **여러 조각의 빈 공간이 흩어져 있어 연속된 큰 공간을 확보하지 못하는 상황**이고,  
내부 단편화는 **미리 정해진 블록이 너무 커서 내부 일부 공간이 낭비되는 상황**입니다.  

즉, 외부 단편화는 ‘연속된 공간 없음’, 내부 단편화는 ‘자투리 공간 낭비’가 핵심 차이입니다.”

---

### **Q3. 주소 변환(논리주소 → 물리주소)에 어떤 구조가 사용되나요?**
**A.**  
“CPU가 생성한 논리 주소는 MMU가 페이지 테이블을 참조해 물리 주소로 변환합니다.  
이 과정에서 TLB라는 고속 캐시가 함께 사용돼 변환 속도를 높이며,  
TLB 미스가 나면 페이지 테이블 접근 비용 때문에 변환 시간이 길어지게 됩니다.”

---

# 2. 중급 질문 (Intermediate)
---

### **Q4. 페이징이 외부 단편화를 해결하는 이유는 무엇인가요?**
**A.**  
“페이징에서는 모든 페이지가 동일한 크기이기 때문에  
‘연속된 큰 공간’이 필요하지 않습니다.  
따라서 메모리가 조각나더라도 페이지 단위로 어디든 배치할 수 있어  
외부 단편화 문제를 자연스럽게 해소할 수 있습니다.”

---

### **Q5. 세그멘테이션이 의미 단위로 나누는 것이 왜 장점인가요?**
**A.**  
“코드, 데이터, 스택처럼 서로 성격이 다른 영역을 독립적으로 관리할 수 있기 때문에  
보안, 접근 제어, 보호 측면에서 유리합니다.  
특정 세그먼트만 읽기 전용으로 만들거나,  
스택만 확장 가능하게 설정하는 식으로 세밀한 메모리 관리가 가능해집니다.”

---

# 3. 심화 질문 (Advanced)
---

### **Q6. TLB는 무엇이며, 왜 중요한가요?**
**A.**  
“TLB는 주소 변환을 빠르게 하기 위한 ‘페이지 테이블 전용 캐시’입니다.  
CPU가 논리 주소를 물리 주소로 변환할 때  
페이지 테이블을 매번 접근하면 비용이 너무 크기 때문에  
최근에 사용한 매핑 정보를 TLB에 저장해 두고,  
매칭이 되는 경우 바로 변환을 수행해 성능을 대폭 높입니다.  

실제로 TLB 미스 비율이 늘어나면 프로그램 전체 성능까지 저하될 수 있습니다.”

---

### **Q7. 페이징 방식에서 주소 변환이 느릴 수 있는 이유는 무엇인가요?**
**A.**  
“페이징은 논리 주소를 ‘페이지 번호 + 오프셋’으로 나누고,  
페이지 번호를 다시 페이지 테이블에서 찾아 물리 주소로 변환해야 합니다.  
즉, 하나의 접근을 위해 **추가 메모리 접근이 필요**하기 때문에 느려질 수 있습니다.  
그래서 TLB가 반드시 필요한 구조가 됩니다.”

---

# 4. 꼬리질문 (Follow-up)
---

### **Q8. 내부 단편화를 줄이기 위해 어떤 전략을 사용할 수 있을까요?**
**A.**  
“내부 단편화는 페이지 크기가 너무 클 때 발생하는데,  
이를 해결하려면 ‘작은 페이지 크기’를 선택하는 것이 기본 전략입니다.  
다만 페이지 크기가 지나치게 작으면 페이지 테이블이 거대해지기 때문에  
페이지 크기와 페이지 테이블 크기의 균형을 잡는 것이 포인트입니다.”

---

### **Q9. 외부 단편화를 줄이기 위한 대표적인 기법은 무엇인가요?**
**A.**  
“세그멘테이션 기반 시스템에서는 외부 단편화를 줄이기 위해  
‘압축(compaction)’이라는 기법을 사용할 수 있습니다.  
메모리의 여러 조각난 빈 공간을 하나로 모아  
연속된 큰 공간을 만들어 주는 방식입니다.  
다만 이 과정은 비용이 커서 실시간 시스템에서는 잘 사용하지 않습니다.”

---

# 5. 실무 질문 (Practical)
---

### **Q10. 서버에서 메모리가 부족(OOM)할 때 어떤 관점으로 진단하시나요?**
**A.**  
“단순히 ‘메모리가 부족하다’가 아니라,  
어떤 영역에서 부족한지를 구체적으로 나눠서 봅니다.  

- JVM Heap이 부족한 것인지  
- OS 레벨에서 페이지 부족으로 스왑이 발생하는지  
- 페이지 테이블/TLB 비효율로 메모리 접근 비용이 큰 것인지  
- 특정 프로세스가 세그먼트를 과도하게 확장하고 있는지  

이렇게 구조적으로 구분하면 어떤 조치를 취해야 하는지 훨씬 명확해집니다.”

---

### **Q11. Docker/K8s 환경에서 메모리 제한이 걸리면 어떤 문제가 발생하나요?**
**A.**  
“컨테이너에 메모리 제한이 걸려 있으면  
페이지 폴트나 스왑이 급증하면서 성능이 급격히 떨어질 수 있습니다.  
특히 메모리 압박이 심해지면 OOM Killer가 특정 프로세스를 강제로 종료시키기 때문에  
메모리 관리 전략을 이해하고 있어야 안전한 배포 구성이 가능합니다.”

---

# 6. 비교 질문 (Comparison)
---

### **Q12. 세그멘테이션 vs 페이징을 한 문장으로 비교해주세요.**
**A.**  
“세그멘테이션은 ‘의미 단위 분할’,  
페이징은 ‘고정 크기 분할’ 방식입니다.”

---

### **Q13. 외부 단편화 vs 내부 단편화 차이는 무엇인가요?**
**A.**  
“외부 단편화는 연속된 공간 부족 문제,  
내부 단편화는 블록 내부 낭비 문제입니다.  
두 문제는 메모리 분할 방식의 근본적 특성 차이에서 옵니다.”
