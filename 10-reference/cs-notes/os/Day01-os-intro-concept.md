# Day01 – 운영체제(OS) 개요 (Concept)

## 1. 이 개념을 왜 배워야 하는가? (문제의식)

운영체제(OS)는 모든 프로그램이 실행되기 위한 **근본 기반**이다.  
백엔드 개발자가 서버에서 겪는 대부분의 문제—CPU 폭주, 메모리 부족(OOM), 스레드 과다 생성, I/O 병목—모두 OS 동작 원리와 직접 연결된다.

운영체제를 모르면:
- 문제가 생겨도 근본 원인을 찾기 어렵고
- 성능 튜닝 방향을 잡지 못하며
- 장애 시 대응 속도도 급격히 느려진다.

운영체제를 알면:
- 서버 성능과 안정성의 핵심 구조를 이해하고
- 동시성 문제를 훨씬 빠르게 해결하며
- 리눅스 기반 시스템을 능숙하게 다룰 수 있게 된다.

즉, OS는 “모든 백엔드 기술의 기초 체력”이다.

---

## 2. 비유로 먼저 이해하기

### 📌 비유 1: “OS는 도시 시장(市長)”
컴퓨터를 도시로 비유하면:
- 도로 = CPU
- 전기/수도 = 메모리, 디스크
- 건물 = 프로그램
- 시민 = 실행중인 작업들

이때 시장(OS)이 없다면 도시 전체는 혼란에 빠진다.  
누가 먼저 도로를 쓰는지, 누가 물을 먼저 쓰는지 정할 사람이 없다.  
OS는 도시 전체의 **질서·공정성·효율성**을 책임진다.

---

### 📌 비유 2: “OS는 주방장”
손님(프로그램)이 요리를 주문하면  
주방장(OS)은 프라이팬(CPU), 재료(메모리), 조리도구(I/O)를  
적절히 배분하고 관리한다.

주방장이 없다면 주방은 10분 안에 난장판이 된다.

---

### 📌 비유 3: “OS는 항공 관제탑”
비행기(작업)들은 항상 이착륙(실행)을 원한다.  
관제탑(OS)이 없으면 충돌 난다.

---

## 3. 개념 정의

운영체제는 **컴퓨터 하드웨어를 관리하고, 프로그램이 실행될 수 있도록 환경을 제공하는 시스템 소프트웨어**이다.

운영체제의 두 핵심 역할:

1) **자원 관리자 (Resource Manager)**  
   - CPU 사용  
   - 메모리 배분  
   - 디스크/파일 관리  
   - I/O 장치 통제  

2) **실행 환경 제공자 (Execution Environment)**  
   - 프로그램 실행  
   - 시스템 콜 제공  
   - 파일 시스템 제공  

즉,  
> 운영체제는 “하드웨어를 안전하고 효율적으로 사용하는 제어 시스템”이다.

---

## 4. 구조로 이해하기 (Architecture)

운영체제는 계층적으로 구성되어 있다.

```
[응용 프로그램]
       ↓
[라이브러리 / API]
       ↓
[시스템콜 인터페이스]
       ↓
[커널 (Kernel)]
       ↓
[하드웨어]
```

### 📌 각 구성 요소 설명

- **응용 프로그램**: 우리가 실행하는 모든 프로그램  
- **라이브러리/API**: OS 기능을 간접적으로 제공  
- **시스템콜 인터페이스**: 프로그램이 커널에 요청하는 “문”  
- **커널(Kernel)**: OS 핵심. 자원 관리·스케줄링·메모리 관리  
- **드라이버**: 하드웨어 제어  
- **하드웨어**: CPU·RAM·SSD·네트워크 카드 등

---

## 5. 동작 원리 (How OS Works)

### ① 프로그램 실행  
프로그램 실행 명령 → OS가 파일을 읽고 메모리에 적재 → **프로세스 생성 준비**  
(프로세스 자체는 Day02에서 다룸)

### ② CPU 스케줄링  
OS의 스케줄러가 CPU를 어떤 작업에게 줄지 결정한다.  
이는 페어플레이처럼 매우 복잡한 정책 기반으로 이루어진다.

### ③ 메모리 관리  
각 프로그램이 필요한 메모리 공간을 적절히 분배하면서  
서로의 공간을 침범하지 못하게 보호한다.

### ④ 파일 시스템 관리  
파일의 생성/삭제/수정/저장 구조를 유지하고  
데이터가 디스크에서 안전하게 관리되도록 한다.

### ⑤ I/O 관리  
키보드·모니터·네트워크·디스크 등 장치들의 동작을  
인터럽트 기반으로 관리한다.

---

## 6. 실제 컴퓨터 내부에서는 무슨 일이 일어나는가?

- 프로그램 실행 시 → OS가 주소 공간 구성  
- OS는 PCB/메모리 테이블 등 내부 구조를 생성  
- 타이머 인터럽트에 따라 CPU는 수십만 번 작업 전환  
- 시스템콜 호출 시 유저 모드 → 커널 모드 전환  
- 커널은 하드웨어를 직접 제어  
- 작업 완료 후 커널 모드 → 유저 모드 복귀  

이 모든 과정이 **1초에도 수만~수백만 번** 반복된다.

OS는 보이지 않지만  
컴퓨터의 “보이지 않는 심장”이다.

---

## 7. 백엔드 개발자에게 왜 중요한가?

운영체제를 이해하면 다음 문제들을 정확히 해결할 수 있다.

- CPU 사용량 급증 원인을 분석  
- 스레드 과다 생성 문제 해결  
- 메모리 누수·GC 문제 해결  
- 파일 I/O 병목 현상 해결  
- 비동기/동시성 작업 설계 능력 상승  
- 서버 장애 분석 속도 향상  

운영체제를 이해하지 못하면  
“왜 서버가 느려지는지, 왜 터지는지" 영원히 감만 잡는 수준에 머문다.

---

## 8. 자주 하는 오해 vs 진실

### ❌ 오해: 프로그램이 CPU를 직접 사용한다  
→ ✔ 진실: OS만 CPU를 직접 제어할 수 있고, 프로그램은 OS에게 요청한다.

### ❌ 오해: 커널은 단순한 실행 파일이다  
→ ✔ 진실: 커널은 스케줄러·메모리 관리자·파일 시스템·드라이버 등  
수천 개 모듈의 복합체이다.

### ❌ 오해: 시스템콜은 단순 함수 호출이다  
→ ✔ 진실: 시스템콜은 CPU 권한을 유저 → 커널로 전환하는  
중요한 보안 메커니즘이다.

---

## 9. 핵심 원리·구조·키워드 10줄 요약

1. 운영체제는 자원을 관리하고 프로그램 실행 환경을 제공하는 시스템 소프트웨어이다.  
2. CPU 권한은 유저 모드와 커널 모드로 구분된다.  
3. OS는 시스템콜을 통해서만 커널 기능을 사용할 수 있게 한다.  
4. 운영체제의 핵심 기능은 프로세스·메모리·파일·I/O 관리 4가지이다.  
5. 커널은 OS의 핵심 부분으로 하드웨어를 직접 제어한다.  
6. OS는 하드웨어를 추상화하여 동일한 API를 제공한다.  
7. 프로그램 실행 과정은 OS의 제어 아래에서 이루어진다.  
8. 내부적으로 인터럽트 기반으로 동작한다.  
9. OS 구조는 계층적이며 유지보수가 용이하다.  
10. 백엔드 성능·안정성·장애 대응의 기반은 OS 지식이다.  
