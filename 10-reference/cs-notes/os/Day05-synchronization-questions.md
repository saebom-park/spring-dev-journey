# Day05 – 동기화 (Questions)

# 1. 기본 질문 (Basic)
---

### **Q1. 동기화란 무엇인가요?**
**A.**  
“동기화는 여러 스레드가 동시에 같은 자원에 접근할 때  
데이터가 꼬이거나 순서가 뒤섞이는 것을 막기 위해  
접근을 제어하는 기법을 말합니다.  
즉 ‘한 순간에 하나의 스레드만 안전하게 사용할 수 있게 하는 보호장치’라고 보면 됩니다.  
이를 통해 경쟁 상태(race condition)를 예방하고 데이터의 일관성을 보장할 수 있습니다.”

---

### **Q2. 임계 구역(Critical Section)이란 무엇인가요?**
**A.**  
“임계 구역은 여러 스레드가 동시에 실행하면 문제가 생기는 코드 영역을 의미합니다.  
예를 들어 공유 변수 업데이트, 리스트 삽입·삭제, 재고 감소 같은 작업이 대표적입니다.  
이 부분은 반드시 ‘한 번에 하나의 스레드만 실행’해야 안전하기 때문에  
락(Mutex, Semaphore 등)으로 보호하는 것이 원칙입니다.”

---

### **Q3. Mutex와 Semaphore의 차이를 간단히 설명해주세요.**
**A.**  
“Mutex는 한 순간에 **오직 하나의 스레드만** 접근하도록 보장하는 단일 락이고,  
Semaphore는 ‘최대 N개까지 동시에 접근’을 허용하는 제한된 락입니다.  
즉 Mutex는 배타적, Semaphore는 다중 허용이라는 차이가 있습니다.”

---

# 2. 중급 질문 (Intermediate)
---

### **Q4. Mutex가 필요한 상황과 필요 없는 상황을 구분해 설명해주세요.**
**A.**  
“하나의 데이터를 여러 스레드가 동시에 수정할 가능성이 있다면 반드시 Mutex가 필요합니다.  
예를 들어 카운터 증가, 재고 감소, 리스트 삽입 같은 연산은  
단 한 번이라도 동시 접근이 일어나면 결과가 왜곡될 수 있기 때문입니다.  

반대로 읽기만 하는 작업이거나,  
각 스레드가 서로 완전히 독립된 데이터를 사용하는 경우라면  
Mutex는 오히려 불필요한 오버헤드만 발생시킵니다.”

---

### **Q5. Semaphore가 실무에서 주로 어떻게 사용되는지 예를 들어 설명해주세요.**
**A.**  
“Semaphore는 ‘동시에 몇 개까지 허용할 것인가’가 중요할 때 사용합니다.  
대표적인 예가 **DB 커넥션 풀**입니다.  
DB는 동시에 너무 많은 연결을 받을 수 없기 때문에  
예를 들어 최대 10개의 permit을 준 뒤,  
그 이상 접근하면 대기하게 만드는 방식으로 사용됩니다.  
이 구조가 자원 고갈을 막고 안정적인 처리량을 유지하게 해줍니다.”

---

# 3. 심화 질문 (Advanced)
---

### **Q6. Spinlock은 어떤 환경에서 유리하고, 어떤 환경에서 불리한가요?**
**A.**  
“Spinlock은 락이 곧 풀릴 것 같은 ‘짧은 대기 상황’에서 매우 유리합니다.  
스레드를 블록시키지 않고 CPU를 계속 사용해 busy-waiting을 하기 때문에  
컨텍스트 스위칭 비용을 아예 제거할 수 있기 때문입니다.  

하지만 락이 오래 걸리는 상황이라면 Spinlock은 치명적으로 비효율적입니다.  
기다리는 동안 계속 CPU를 태워버리기 때문에  
오히려 전체 시스템 성능을 떨어뜨립니다.  
그래서 Spinlock은 커널 내부나 짧은 임계구역에서만 사용되는 편입니다.”

---

### **Q7. 락을 과도하게 사용하면 왜 성능이 떨어지나요?**
**A.**  
“락이 많아질수록 공유 자원에 접근하려는 스레드가 증가하고  
대기 시간이 증가합니다.  
또한 락을 획득·반납하는 자체 비용도 만만치 않아서  
임계 구역이 커질수록 전체 처리량이 떨어집니다.  

즉, 동기화는 필요하지만 **범위를 최소화**하는 것이 핵심이며  
‘데이터를 보호하려고 넣은 락이 오히려 시스템 병목을 만드는 상황’을  
항상 경계해야 합니다.”

---

# 4. 꼬리질문 (Follow-up)
---

### **Q8. Mutex와 Spinlock 중 무엇을 선택할지 어떻게 결정하나요?**
**A.**  
“기다리는 시간이 **매우 짧다면 Spinlock**,  
반대로 시간이 **길거나 예측이 어렵다면 Mutex**를 선택합니다.  

Spinlock은 블록되지 않기 때문에  
빠른 락 획득/해제가 반복되는 상황에서는 최고의 성능을 내지만,  
조금이라도 대기 시간이 길어지면 CPU를 계속 소모해 오히려 더 느립니다.  
서버 애플리케이션에서는 보통 Mutex 계열이 더 적합합니다.”

---

### **Q9. 세마포어의 permit이 모두 소진되면 OS 내부에서는 어떤 일이 벌어지나요?**
**A.**  
“permit이 0이 되면 추가 스레드는 더 이상 접근할 수 없기 때문에  
블록(block) 상태로 전환되고,  
해당 스레드는 OS의 스케줄러에 의해 대기 큐로 이동합니다.  
그리고 다른 스레드가 permit을 반납(release)하는 순간  
대기 중인 스레드가 깨워져 다시 Ready 상태로 돌아옵니다.  
이 과정을 통해 허용량을 일정하게 유지하면서  
안정적인 자원 사용을 보장할 수 있습니다.”

---

# 5. 실무 질문 (Practical)
---

### **Q10. 동기화가 제대로 되지 않아 발생하는 버그는 어떤 모습으로 나타나나요?**
**A.**  
“대표적으로 값이 왜곡되는 형태로 나타납니다.  
예를 들어 재고 감소가 1씩 줄어야 하는데 0이 되거나 2가 되는 식으로  
덧셈·뺄셈 같은 기본 연산 결과가 틀어지기 시작합니다.  
특히 재현이 매우 어렵고 간헐적으로 발생하기 때문에  
문제 원인을 찾는 데 큰 어려움을 겪게 됩니다.  
이런 오류는 거의 대부분 동기화가 올바르게 적용되지 않았을 때 발생합니다.”

---

### **Q11. 스레드 수를 늘렸더니 오히려 성능이 떨어지는 이유가 무엇인가요?**
**A.**  
“스레드 수가 늘어나면 동시 접근이 많아지고,  
락 획득 경쟁이 심해지면서 대기 시간이 커집니다.  
또한 컨텍스트 스위칭 비용까지 증가하기 때문에  
CPU는 ‘실제 작업’보다 ‘스레드 전환 작업’에 더 많은 시간을 쓰게 됩니다.  
그래서 동기화가 필요한 구간이 많은 시스템이라면  
스레드를 무조건 늘리는 것이 성능을 보장하지 않습니다.”

---

# 6. 비교 질문 (Comparison)
---

### **Q12. Mutex vs Semaphore를 한 문장으로 비교해주세요.**
**A.**  
“Mutex는 한 명만 들어갈 수 있는 화장실,  
Semaphore는 동시에 여러 명이 들어갈 수 있는 주차장입니다.”

---

### **Q13. Spinlock vs Blocking Lock의 차이를 한 문장으로 설명해주세요.**
**A.**  
“Spinlock은 락을 얻을 때까지 계속 확인하면서 CPU를 쓰는 방식이고,  
Blocking Lock은 락을 얻을 수 없으면 스레드를 잠시 재워 CPU를 아끼는 방식입니다.”
