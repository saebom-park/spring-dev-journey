# Day04 – 메모리 관리 (Concept)

## 1. 이 개념을 왜 배워야 하는가? (문제의식)

백엔드 서버는 실행되는 동안 수많은 변수, 객체, 스레드, 캐시 데이터를 메모리에 올려놓고 사용한다.  
이때 운영체제가 **어떤 기준으로 메모리를 배치하고**,  
**어떤 방식으로 프로그램이 필요한 주소를 찾고**,  
**어떻게 단편화를 해결하는지** 이해하지 못하면 다음과 같은 문제가 생긴다:

- 메모리 부족(OOM)이 왜 발생했는지 판단할 수 없음  
- 캐시 중복, 객체 누수 등 메모리 비효율을 분석할 수 없음  
- JVM의 Heap/Stack 구조를 봐도 의미 해석이 불가능  
- 대규모 데이터 처리 시 성능 병목을 정확히 파악할 수 없음  

반면 이를 이해하면:
- 메모리 사용량과 성능 문제를 논리적으로 분석할 수 있고  
- Java의 메모리 모델(Heap, Stack, GC)을 훨씬 더 깊게 이해할 수 있으며  
- 대규모 시스템에서 안정적인 메모리 구조를 설계할 수 있다  

즉, 메모리 관리는 **OS·JVM·애플리케이션 전체를 관통하는 핵심 추상화**다.

---

## 2. 비유로 먼저 이해하기

### 📌 비유 1: “집을 방 단위로 나누는 방식”
- **세그멘테이션(Segmentation)**: 방을 목적에 따라 나눔(침실, 주방, 화장실)  
- **페이징(Paging)**: 방을 모두 똑같은 크기의 정사각형으로 나눔  

서로 장단점이 분명하다.

---

### 📌 비유 2: “주소를 찾는 두 가지 방식”
- 세그먼트 방식: *“방 종류 + 안의 위치”*  
- 페이지 방식: *“n번째 정사각형 조각”*  

CPU가 실제 물리 주소를 찾는 과정도 이와 똑같다.

---

### 📌 비유 3: “토막 난 땅(단편화)”
- **외부 단편화**: 땅이 이리저리 쪼개져 공간이 있어도 활용 불가  
- **내부 단편화**: 큰 땅을 배정하고 자투리 공간이 낭비됨  

운영체제 메모리에서도 이런 낭비가 그대로 발생한다.

---

## 3. 공식 개념 정의

### ✔ 메모리 관리(Memory Management)
운영체제가 **프로세스에게 메모리를 어떻게 할당하고, 주소 변환을 어떻게 수행하는지**를 정의하는 구조.

핵심 목표:
- 메모리를 효율적으로 사용  
- 단편화 최소화  
- 빠른 주소 변환  
- 안정성·보안 확보  

---

## 4. 세그멘테이션(Segmentation)

### ✔ 개념
프로그램을 의미 단위(세그먼트)로 나누어 메모리를 배치하는 방식.  
예: Code, Data, Heap, Stack 각각을 독립 영역으로 분리.

### ✔ 특징
- 세그먼트 크기가 서로 다름  
- “세그먼트 번호 + 오프셋”으로 주소 계산  
- 의미 있는 단위로 나눠 구조적 관리가 쉬움  
- 보안 측면에서 유리 (코드/데이터 분리)

### ✔ 단점
- 크기가 다른 조각들 때문에 **외부 단편화** 발생  
- 세그먼트 크기 관리가 복잡  

---

## 5. 페이징(Paging)

### ✔ 개념
메모리를 **동일한 크기의 페이지(Page)**로 나누어 관리하는 방식.

### ✔ 특징
- 모든 페이지가 **동일한 크기**  
- 주소 = “페이지 번호 + 페이지 내부 위치”  
- 외부 단편화 없음  
- 페이지 테이블을 사용해 논리 주소 → 물리 주소 변환

### ✔ 단점
- 마지막 페이지 내부의 자투리 공간 → **내부 단편화**  
- 페이지 테이블이 커질수록 메모리 관리 오버헤드 증가  

---

## 6. 페이징 + 세그멘테이션 혼합 방식

실제 운영체제는 두 방식의 장점을 취해 **세그먼트 단위로 나누고, 각 세그먼트를 다시 페이지로 분할**하는 구조를 사용한다.

이 방식의 장점:
- 구조화된 관리(세그먼트 이점)  
- 외부 단편화 최소화(페이징 이점)  
- 주소 변환 유연성 증가  

대표적으로 현대 OS(리눅스, 윈도우 대부분)가 이런 구조 기반.

---

## 7. 단편화(Fragmenation)

### ✔ 외부 단편화
- 메모리가 이리저리 쪼개져 있어  
  “전체 크기만 보면 충분한데 연속된 공간이 부족한 상황”  
- 세그멘테이션에서 자주 발생

### ✔ 내부 단편화
- 페이지 크기 때문에 실제 필요보다 더 큰 공간이 할당되면서  
  페이지 내부 일부 공간이 낭비되는 상황  
- 페이징에서 발생

---

## 8. 실제 컴퓨터 내부에서는 어떤 일이 일어나는가?

- CPU는 논리 주소(Logical Address)를 발생  
- MMU(Memory Management Unit)가 이를 물리 주소(Physical Address)로 변환  
- 페이징 기반 시스템일 경우  
  - 페이지 테이블을 참조  
  - TLB(Translation Lookaside Buffer)를 캐시처럼 사용  
- TLB 미스가 발생하면 주소 변환 성능이 크게 저하  
- 메모리가 부족하면 스왑 영역으로 밀려나고, 성능 급락이 시작됨  

결국 “주소 변환 → 페이지 테이블 → TLB → 스왑” 모두 이해해야  
서버가 느려질 때 원인을 정확히 찾을 수 있다.

---

## 9. 백엔드 실무에서 왜 중요한가?

- JVM Heap 사이즈 조정 시  
  “왜 메모리가 부족한지” 근본 이해 가능  
- OOM(OutOfMemoryError) 원인 분석  
- 대량 캐시/배치 작업에서 메모리 구조 설계  
- 리눅스 메모리 사용량 분석 (free, top, vmstat 등)  
- Docker/K8s 메모리 제한 환경에서 스왑이 성능에 미치는 영향 분석  

메모리 관리 원리를 모르고 Heap만 늘렸다 줄였다 하면  
근본적인 튜닝이 불가능하다.

---

## 10. 핵심 요약 10줄

1. 메모리 관리는 주소 배치·변환·보호를 관리하는 OS의 핵심 기능이다.  
2. 세그멘테이션은 의미 단위로 나누는 방식이다.  
3. 페이징은 고정된 크기 단위로 나누는 방식이다.  
4. 세그멘테이션은 외부 단편화가 생긴다.  
5. 페이징은 내부 단편화가 생긴다.  
6. 현대 OS는 둘을 결합한 방식을 많이 쓴다.  
7. MMU가 주소 변환을 담당한다.  
8. 페이지 테이블은 주소 변환의 핵심 자료구조이다.  
9. TLB는 주소 변환 캐시 역할을 한다.  
10. 스왑이 발생하면 성능이 급격히 저하된다.
