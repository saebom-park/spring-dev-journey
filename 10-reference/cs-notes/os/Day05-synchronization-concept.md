# Day05 – 동기화 (Synchronization) (Concept)

## 1. 이 개념을 왜 배워야 하는가? (문제의식)

백엔드 서버에서는 여러 스레드가 동시에 같은 자원(공유 변수, 캐시, 리스트, DB 커넥션 등)에 접근한다.  
이때 **한 스레드가 값을 수정하는 순간**, 다른 스레드가 동시에 접근하면  
데이터가 꼬이거나, 순서가 뒤섞이거나, 아예 장애로 이어질 수 있다.

이를 동시성 문제(Concurrency Bug)라고 하며 대표적으로 다음과 같은 증상이 나타난다:

- 계산 결과가 비정상적으로 나옴  
- 카운터·재고·포인트 같은 값이 왜곡됨  
- 트랜잭션이 꼬이면서 쓰기 순서 불일치 발생  
- 스레드 풀은 정상인데 요청 결과만 틀림 → 디버깅 매우 어려움  

이 문제를 해결하는 개념이 바로 **동기화(Synchronization)** 이다.

동기화를 정확히 이해하면:
- 경쟁 상태(race condition)를 원리적으로 파악할 수 있고  
- Mutex, Semaphore, Spinlock 같은 락의 성질을 판단할 수 있으며  
- Java에서 synchronized, Lock, atomic 계열 구조를 올바르게 선택할 수 있다  

즉, 동기화는 **“여러 스레드가 함께 일해도 데이터가 망가지지 않도록 만드는 안전장치”**를 배우는 것이다.

---

## 2. 비유로 먼저 이해하기

### 📌 비유 1: “화장실 한 칸”
화장실이 단 하나뿐이라면:
- 한 명씩 들어가야 함 → **Mutex (상호배제)**
- 안에서 누가 쓰는지 문고리에 ‘사용 중’ 표시 → **락**

누군가 문 앞에서 계속 기다리는 상황은  
CPU로 치면 **Spinlock(계속 확인)** 또는 **블로킹 락(기다림)**이다.

---

### 📌 비유 2: “주차장 입구”
- 주차장이 3대까지 가능 → **Semaphore(허용량 있음)**  
- 자리가 다 차면 대기해야 함  
- 한 자리 비면 들어가는 것은 **permit 획득**로 표현할 수 있다.

---

### 📌 비유 3: “줄을 서야 하는 이유”
여러 사람이 동시에 무언가를 수정하면 순서가 무너진다.  
동기화는 “수정 권한을 한 번에 한 사람에게만 주는 구조”라고 보면 된다.

---

## 3. 공식 개념 정의

### ✔ 동기화(Synchronization)
여러 스레드가 **공유 자원에 동시에 접근할 때 발생할 수 있는 경쟁 상태를 방지**하기 위한 기술.

핵심 목표:
- 데이터 일관성(consistency) 유지  
- 경쟁 상태(race condition) 방지  
- 교착 상태(deadlock) 없이 안전한 실행 보장  

---

## 4. 임계 구역(Critical Section)

### ✔ 개념
공유 자원을 읽거나 쓰는 **가장 위험한 코드 영역**.  
이 부분을 동시에 실행하면 데이터가 깨진다.

### ✔ 조건 (Mutual Exclusion Problem의 3요구사항)
1. **Mutual Exclusion(상호 배제)**: 한 번에 하나의 스레드만 진입  
2. **Progress(진행)**: 누구를 다음에 진입시킬지 결정 가능해야 함  
3. **Bounded Waiting(한정된 대기)**: 특정 스레드가 무한히 기다리면 안 됨  

임계구역을 보호하는 방식이 바로 Mutex / Semaphore / Spinlock이다.

---

## 5. Mutex

### ✔ 개념
Mutual Exclusion(상호 배제)를 제공하는 **단일 락(lock)**.

### ✔ 특징
- 한 순간에 하나의 스레드만 락을 가질 수 있음  
- 락을 가진 스레드만 임계 구역 실행 가능  
- unlock을 반드시 호출해야 함  
- OS 또는 라이브러리 수준에서 구현  

### ✔ Java에서는?
- `synchronized`
- `ReentrantLock`  
- 이 두 가지가 대표적인 Mutex 구현이다.

---

## 6. Semaphore

### ✔ 개념
여러 스레드가 동시에 접근할 수 있지만 **최대 허용량(permits)**을 제한하는 락.

예: DB 커넥션 풀은 보통 Semaphore로 동작  
— “최대 10개까지만 동시에 사용 가능”

### ✔ 특징
- permit 개수만큼 동시에 허용  
- permit이 0이면 대기  
- Mutex는 permit = 1인 Semaphore라고 볼 수도 있다  

---

## 7. Spinlock

### ✔ 개념
락을 얻을 때까지 “계속 확인하는(Busy Waiting)” 방식.

### ✔ 특징
- 락이 금방 풀릴 것 같을 때 유리  
- context switching 비용 없음 (스레드를 블록시키지 않음)  
- CPU를 계속 소모하기 때문에 장시간 대기에는 비효율적  
- 커널 레벨 또는 고성능 환경에서 많이 사용  

---

## 8. 실제 컴퓨터 내부에서는 어떤 일이 일어나는가?

- 스레드 A가 락을 얻으면 해당 자원에 대한 독점 권한을 갖는다  
- 스레드 B가 접근하면 락 상태를 보고  
  - 락이 열려 있으면 → 진입  
  - 닫혀 있으면 → 대기 or busy-waiting  
- unlock 시점에는 내부 큐에 대기 중인 스레드가 깨우침  
- 이 과정에서 context switching, 스케줄링, 우선순위 반영 등이 함께 동작  

대기 방식(Spin vs Block)이 성능에 큰 차이를 만든다.

---

## 9. 실무에서 왜 중요한가?

동기화 개념을 모르면 아래 상황을 디버깅할 수 없다.

- 재고 감소/증가 값이 틀림  
- Redis나 MySQL을 사용했는데도 값이 왜곡됨  
- synchronized를 너무 남발해서 전체 서버 성능이 급락  
- 잘못된 락 설계로 인해 교착상태 발생  
- 스레드 수 확대 시 오히려 성능이 떨어짐  

반대로 동기화를 이해하면:
- 병목 지점 추적 가능  
- 락 범위를 최소화해 성능 최적화 가능  
- 원자성(atomicity)·가시성(visibility)을 고려한 설계 가능  

---

## 10. 핵심 요약 10줄

1. 동기화는 공유 자원을 보호하기 위한 기술이다.  
2. 임계 구역은 동시에 접근하면 안 되는 위험 지점이다.  
3. Mutex는 단일 락 기반 상호 배제다.  
4. Semaphore는 여러 개를 동시에 허용하는 제한된 락이다.  
5. Spinlock은 락이 풀릴 때까지 계속 확인한다.  
6. 상호 배제·진행·한정 대기 조건을 만족해야 한다.  
7. 락의 범위를 좁히는 것이 성능의 핵심이다.  
8. 잘못된 락 설계는 교착상태를 만든다.  
9. Java에서는 synchronized / Lock이 Mutex 역할을 한다.  
10. 동기화는 동시성 버그를 막기 위한 백엔드 개발자의 핵심 무기다.
