# Day02 – 프로세스와 스레드 (Concept)

## 1. 이 개념을 왜 배워야 하는가? (문제의식)

백엔드 서버는 동시에 수많은 요청을 처리한다.  
클라이언트가 주는 부담, DB I/O 대기, 외부 API 호출, CPU 연산이 한꺼번에 몰리기 때문에  
프로세스와 스레드의 구조를 이해하지 못하면 서버가 왜 느려지는지,  
왜 스레드 풀이 폭주하는지, 왜 CPU가 100%가 되는지도 정확히 알 수 없다.

운영체제는 “무엇을 실행할지”, “어떤 자원을 어떻게 나눌지”를 결정하지만  
그 기본 단위가 바로 **프로세스와 스레드**다.

이를 모르면:
- 서버 성능 문제의 원인을 분석할 수 없고  
- 스레드 풀 튜닝이 불가능하며  
- 동시성 버그를 해결할 수 없다  

반대로 이해하면:
- 병목을 정확하게 찾을 수 있고  
- 안전한 동시성 코드를 작성할 수 있으며  
- Java 기반 서버의 스레드 모델을 완전히 이해하게 된다  

즉, 프로세스와 스레드는 **백엔드 개발자의 필수 근력**이다.

---

## 2. 비유로 먼저 이해하기

### 📌 비유 1: “프로세스는 집, 스레드는 사람”
- 프로세스 = 독립된 집  
- 스레드 = 집 안에서 움직이는 사람  

집들은 서로의 방, 부엌, 물건을 공유하지 않는다.  
하지만 같은 집 안의 사람들은 집의 자원(부엌, 냉장고, 화장실)을 함께 쓰며 충돌할 수 있다.

---

### 📌 비유 2: “프로세스는 회사, 스레드는 직원”
- 회사는 서로 독립된 공간  
- 직원은 같은 회사 내부의 리소스를 함께 사용  

직원이 많아지면 업무는 빨라지지만,  
프린터·회의실 같은 공유 자원에서 충돌이 생기고 생산성이 떨어질 수 있다.  
이는 스레드가 많아지는 상황과 매우 유사하다.

---

### 📌 비유 3: “프로세스는 세계, 스레드는 세계를 움직이는 손발”
프로세스는 프로그램 전체가 존재할 수 있는 ‘세계’고  
스레드는 그 세계를 실제로 움직이는 실행 흐름이다.

---

## 3. 공식 개념 정의

### ✔ 프로세스(Process)
운영체제로부터 **독립된 메모리 공간과 자원**을 할당받아 실행되는 프로그램.

#### 주요 특징
- 독립된 주소 공간(Code, Data, Heap, Stack 全부 분리)
- PCB(Process Control Block)로 관리됨
- 생성/종료 비용이 큼
- 서로 간섭 불가능 (안전함)

---

### ✔ 스레드(Thread)
프로세스 내부에서 실행되는 **최소 실행 흐름 단위**.  
같은 프로세스의 자원을 공유한다.

#### 주요 특징
- Code/Data/Heap 공유
- Stack만 개별
- 생성/종료가 매우 빠름
- 서로 공유 자원 충돌 위험 있음

---

## 4. 구조로 이해하기 (메모리 구조 포함)

하나의 프로세스는 다음과 같은 구조를 가진다:

```
┌──────────────────┐
│      Code         │  ← 스레드들과 공유
├──────────────────┤
│      Data         │  ← 스레드들과 공유
├──────────────────┤
│      Heap         │  ← 스레드들과 공유
├──────────────────┤
│   Thread Stack1   │  ← 스레드별 독립
├──────────────────┤
│   Thread Stack2   │
├──────────────────┤
│   Thread Stack3   │
└──────────────────┘
```

### ✔ 핵심 포인트
- **Heap, Code, Data는 스레드 간 공유 → 경쟁 상태 발생 가능**
- **Stack은 스레드마다 독립 → 함수 호출, 지역변수 저장 공간**

---

## 5. 동작 원리 (CPU 레벨에서)

### ✔ 1) 프로세스 생성 과정
1. 프로그램 실행 요청  
2. OS가 PCB 생성  
3. 독립된 주소 공간 생성  
4. 필요한 파일 핸들, 메모리 자원 할당  
5. 스케줄러가 CPU 시간을 배분

---

### ✔ 2) 스레드 생성 과정
1. 기존 프로세스의 주소 공간을 공유  
2. 독립된 Stack 생성  
3. Program Counter(PC), 레지스터 값 등 생성  
4. 스케줄러가 “스레드 단위”로 CPU를 배분  
   (현대 OS는 스레드를 스케줄링 단위로 사용)

---

### ✔ 3) 컨텍스트 스위칭
스레드가 많아질수록 자주 일어나는 작업:

1. 현재 스레드의 레지스터/PC 값을 PCB/TBB에 저장  
2. 다음 스레드의 저장된 값을 CPU에 로드  
3. 실행 재개  

→ 이 비용이 크기 때문에 스레드를 무작정 늘리면 성능이 급격히 떨어진다.

---

## 6. 실제 컴퓨터 내부에서는 어떤 일이 일어나는가?

- CPU는 한 순간에 “단 하나의 스레드만” 실행  
- 인터럽트가 발생하면 즉시 스레드를 전환  
- 공유 자원에 여러 스레드가 접근하면 경쟁 상태 발생  
- 메모리가 부족하면 스레드 생성 실패 또는 OOM  
- 프로세스끼리는 절대 메모리를 공유하지 않음 → IPC 필요  

이 모든 동작은 1초에도 수십만 번 이상 일어난다.

---

## 7. 백엔드 실무에서 왜 중요한가?

실무에서는 다음과 같은 문제가 전부 스레드·프로세스와 연관되어 있다.

### ✔ 서버가 갑자기 느려질 때  
- 스레드 풀 고갈  
- 컨텍스트 스위칭 폭증  
- CPU 100%  
- DB 커넥션 풀 대기  

### ✔ Java 기반 서버에서  
- Tomcat 스레드 풀  
- @Async 스레드 관리  
- CompletableFuture / ExecutorService  
- HikariCP 커넥션 풀  
- 비동기 + 논블로킹 I/O

이 모든 것이 결국 OS 스레드 자원 위에서 돌아간다.

---

## 8. 자주 하는 오해 vs 진실

### ❌ 오해 1: 스레드는 메모리를 거의 안 먹는다  
→ ✔ 스레드 하나당 Stack이 최소 수백 KB ~ 수 MB까지 사용 가능하다.

### ❌ 오해 2: 스레드를 늘리면 성능이 무조건 좋아진다  
→ ✔ 컨텍스트 스위칭 비용이 폭발해 성능이 떨어진다.

### ❌ 오해 3: 프로세스끼리 메모리를 공유할 수 있다  
→ ✔ 절대 불가능. 공유하려면 반드시 IPC가 필요하다.

---

## 9. 핵심 원리·구조·키워드 10줄 요약

1. 프로세스는 독립된 실행 단위이며 전용 주소 공간을 가진다.  
2. 스레드는 프로세스 내부의 실행 흐름이다.  
3. Code/Data/Heap은 스레드 간 공유된다.  
4. Stack만 스레드별로 독립적이다.  
5. 프로세스 생성 비용은 크고, 스레드는 매우 가볍다.  
6. CPU는 스레드 단위로 스케줄링한다.  
7. 컨텍스트 스위칭 비용은 매우 크다.  
8. 스레드 수가 많아지면 성능이 떨어질 수 있다.  
9. 프로세스 간 통신은 IPC 필요, 스레드 간은 공유 메모리 사용.  
10. 백엔드 서버 성능 문제는 대부분 스레드·프로세스 구조와 관련된다.
