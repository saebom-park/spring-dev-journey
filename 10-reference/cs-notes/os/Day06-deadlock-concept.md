# Day06 – 교착상태(Deadlock) (Concept)

## 1. 이 개념을 왜 배워야 하는가? (문제의식)

멀티스레드 서버, DB 트랜잭션, 락 기반 동시성 처리에서  
교착상태는 가장 찾기 어렵고 가장 치명적인 문제 중 하나다.

다음과 같은 증상이 나타난다면 대개 교착상태가 의심된다:

- 일부 요청은 잘 되는데 특정 요청만 계속 멈춤  
- CPU 사용률은 낮지만 스레드가 모두 바쁘게 보임  
- DB는 살아있지만 트랜잭션이 끝나지 않음  
- 스레드 덤프에서 특정 스레드들이 서로를 기다리고 있음  

교착상태는 **“두 개 이상의 프로세스/스레드가 서로가 가진 자원을 기다리다가 모두 멈춰버리는 상태”**이다.

교착상태를 이해하면:
- 스레드·트랜잭션 병목을 구조적으로 찾을 수 있고  
- MySQL/InnoDB의 락 대기 문제를 해석할 수 있으며  
- 락 설계 및 공유 자원 관리 전략을 바르게 세울 수 있다  

즉, 교착상태는 실무에서 “한 번 발생하면 서비스 전체가 멈추는” 심각한 문제이기 때문에  
그 원리와 해결법을 반드시 알고 있어야 한다.

---

## 2. 비유로 먼저 이해하기

### 📌 비유 1: “좁은 길에서 두 차가 서로 마주 보고 멈춘 상황”
A차는 B차가 비켜야 지나가고  
B차는 A차가 비켜야 지나간다.

둘 다 기다리기만 하고,  
둘 중 누구도 뒤로 물러날 수 없는 상황 → **교착상태**

---

### 📌 비유 2: “포크 두 개가 필요한 식사 게임(식사하는 철학자 문제)”
철학자들은 포크 두 개를 집어야 밥을 먹을 수 있다.  
왼쪽 포크를 잡고 오른쪽 포크를 잡으려고 하는데  
모두 왼쪽 포크만 잡고 오른쪽을 대기한다면?  
→ 영원히 밥을 못 먹음 = 교착상태

---

### 📌 비유 3: “두 명이 서로를 기다리는 회전문”
한 명은 밖에서 안을 기다리고  
한 명은 안에서 밖을 기다리면  
서로 양보하지 않는 한 꽉 막히는 상황.

---

## 3. 공식 개념 정의

### ✔ 교착상태(Deadlock)
두 개 이상의 프로세스(또는 스레드)가  
**서로가 가진 자원(Resource)을 기다리면서**  
영원히 실행이 진행되지 않는 상태.

---

## 4. 교착상태 발생 조건 (4가지)

❗ **네 가지 조건이 모두 충족될 때 교착상태가 발생한다.**  
이를 **Coffman 조건**이라고 한다.

### ✔ 1) 상호 배제(Mutual Exclusion)
한 번에 하나의 프로세스만 특정 자원 사용 가능  
(예: Mutex로 보호된 자원)

### ✔ 2) 점유와 대기(Hold and Wait)
이미 자원을 가진 상태에서  
추가 자원을 요청하고 기다리는 상황

### ✔ 3) 비선점(Non-preemption)
자원을 강제로 빼앗을 수 없음  
(락을 스레드가 직접 반납해야 함)

### ✔ 4) 순환 대기(Circular wait)
P1은 P2의 자원을 기다리고  
P2는 P3의 자원을 기다리고  
P3는 P1의 자원을 기다리는 식의 고리 구조

이 네 가지가 동시에 만족될 때 교착상태가 발생한다.

---

## 5. 교착상태 예방(Prevention)

교착상태를 원천 차단하기 위해 “4가지 조건 중 일부를 절대 성립하지 않게 만드는 방식”.

### ✔ 1) 상호 배제 제거 → 사실상 불가능
공유 자원을 공유하지 않게 한다?  
현실적으로 불가능.

### ✔ 2) 점유와 대기 방지
자원을 요청하기 전에 모든 자원을 한 번에 받아야 한다.  
→ 비효율적이라 잘 사용하지 않음.

### ✔ 3) 비선점 제거
자원을 강제로 빼앗을 수 있게 만든다.  
→ 가능은 하지만 자원의 안전성이 깨질 수 있음.

### ✔ 4) 순환 대기 방지 (가장 실용적)
**모든 락을 동일한 순서로 획득**하게 만드는 방법.  
예: 항상 A → B 순서로만 락을 획득하도록 규칙 설정.

이 방식은 실무에서 가장 많이 쓰는 교착상태 예방 방법이다.

---

## 6. 교착상태 회피(Avoidance)

예방은 너무 보수적이어서 성능이 나쁘다.  
그래서 “지금 이 자원을 줘도 안전한지”를 판단해  
위험한 상황이면 잠시 대기시키는 방식이 **회피(Avoidance)**다.

### ✔ 대표 알고리즘: 은행원 알고리즘(Banker's Algorithm)

은행원이 대출을 해주는 상황을 비유로 한 알고리즘이다:

- 고객이 요청한 금액을 지금 줘도  
- 결국 모든 고객이 대출을 갚고  
- 시스템이 안정 상태(Safe State)를 유지할 수 있을지 검사한다.

만약 요청을 허용하면 교착상태가 생길 위험이 있다면  
**요청을 일시적으로 거절**한다.

즉:
> “안전하면 허용, 불안전하면 잠시 대기”

회피 방식의 핵심 아이디어다.

---

## 7. 교착상태 탐지 및 복구(Detection & Recovery)

예방이나 회피가 어렵다면  
“교착상태를 허용하고, 문제 발생 후에 해결하는 방식”이다.

### ✔ 탐지
- 자원 할당 그래프(Resource Allocation Graph) 분석  
- 순환 대기 여부 검사  
- OS가 주기적으로 데드락 감지  
- DBMS(InnoDB)에서 대표적: **락 대기 타임아웃 검사**

### ✔ 복구
1) 교착상태에 빠진 프로세스 강제 종료  
2) 일부 트랜잭션 롤백  
3) 자원 일부 회수  

실무에서는 DB 트랜잭션이 멈췄을 때  
“InnoDB Lock wait timeout exceeded” 같은 메시지가 이 과정이다.

---

## 8. 실제 컴퓨터 내부에서는 어떤 일이 벌어지나?

- 스레드 A가 자원 1을 잡고, 자원 2를 기다림  
- 스레드 B가 자원 2를 잡고, 자원 1을 기다림  
- 둘 다 상대가 가진 락을 기다리면서 block 상태  
- 스케줄러가 아무리 스레드를 바꿔도 실행되지 않음  
- 계속 block 상태가 유지되므로 CPU 사용률은 낮지만, 스레드는 멈춤  

이때 시스템은 ‘멈춘 스레드가 많아지고 있지만 CPU는 놀고 있는’ 비정상 상태로 보인다.

---

## 9. 실무에서 왜 중요한가?

- 잘못된 락 순서로 인해 웹 요청 일부가 영원히 대기  
- DB 트랜잭션이 lock wait 상태에서 timeout 발생  
- 스레드 덤프를 보면 특정 스레드만 기다리는 상태  
- 서버가 안 죽었는데 응답은 멈춤 → 대부분 교착상태  
- 트래픽 증가 시 백엔드 스레드들이 서로의 락을 기다리면서 전체 서비스 지연  

교착상태는 **재현이 어렵고 관측이 더 어려운 문제**라  
발생 원리와 탐지법을 확실히 알아야 한다.

---

## 10. 핵심 요약 10줄

1. 교착상태는 서로가 가진 자원을 기다리며 영원히 멈추는 상태다.  
2. 상호 배제, 점유와 대기, 비선점, 순환 대기 4조건이 모두 충족될 때 발생한다.  
3. 예방은 조건 중 하나를 파괴하는 방식이다.  
4. 순환 대기 방지(락 획득 순서 통일)가 가장 실용적이다.  
5. 회피는 안전 상태를 유지하며 위험할 때만 요청을 보류한다.  
6. 대표적인 회피 방식이 은행원 알고리즘이다.  
7. 탐지 방식은 자원 그래프 분석과 순환 대기 검사다.  
8. 복구는 프로세스 종료나 롤백 같은 방식으로 해결한다.  
9. CPU는 놀고 있어도 스레드는 서로를 기다리며 멈출 수 있다.  
10. 교착상태는 실무에서 매우 위험하고 발견이 어려운 동시성 문제다.
