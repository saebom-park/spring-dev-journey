# Day03 – CPU 스케줄링 (Concept)

## 1. 이 개념을 왜 배워야 하는가? (문제의식)

웹 서버, 배치 서버, 마이크로서비스들은 동시에 수많은 요청을 처리한다.  
이때 “어떤 요청을 먼저 처리할지”, “CPU를 누구에게 얼마나 오래 줄지”를 결정하는 게 바로 **CPU 스케줄링**이다.

이 개념을 모르면:
- 서버가 느려질 때 **무엇부터 봐야 하는지** 감이 안 잡히고  
- 런큐 길이, CPU 100% 같은 지표를 봐도 **원인을 해석할 수 없으며**  
- 스레드 풀 개수나 비동기 처리 설정을 바꿔도 **왜 좋아졌는지, 왜 나빠졌는지** 설명할 수 없다.

반대로 이해하면:
- “지금 서버가 느린 이유가 CPU 스케줄링 관점에서 뭔지”를 구조적으로 설명할 수 있고  
- 스레드 풀 사이즈, 타임아웃, 비동기 처리 전략을 **근거 있게** 조정할 수 있으며  
- 운영체제·JVM·애플리케이션이 서로 어떤 식으로 CPU를 나눠 쓰는지 큰 그림을 잡을 수 있다.

즉, CPU 스케줄링은 **성능 튜닝과 장애 분석의 언어**다.  
이 원리를 알고 있으면, 단순히 “느리다” 수준이 아니라  
“어떤 시점에, 어떤 유형의 작업이, 어떤 이유로 밀리고 있는지”까지 말할 수 있게 된다.

---

## 2. 비유로 먼저 이해하기

### 📌 비유 1: “놀이공원 줄 서기”

놀이기구 하나(= CPU)에 줄이 잔뜩 서 있다고 생각해보자.

- **FCFS**: 먼저 온 사람부터 태운다.
- **SJF**: 빨리 끝날 것 같은 사람부터 태운다.
- **Priority**: VIP 손님부터 태운다.
- **RR**: 모든 손님을 조금씩 번갈아 태운다.

핵심은 “누구를 먼저 태우느냐”에 따라  
**평균 대기 시간, 공정성, 체감 응답 속도**가 확 달라진다는 거다.

---

### 📌 비유 2: “병원 대기실”

병원 진료도 비슷하다.

- 도착 순서대로 진료 → FCFS  
- 위급 환자 먼저 → Priority  
- 간단한 처치부터 빨리 처리 → SJF  
- 여러 명을 조금씩 돌아가며 진료 → RR

어떤 원칙으로 순서를 정하느냐에 따라  
**어떤 환자가 오래 기다리는지, 전체 대기열이 어떻게 움직이는지**가 달라진다.

---

### 📌 비유 3: “편의점 계산대”

계산대(= CPU)에 손님(= 프로세스/스레드)이 줄을 서 있다.

- 시간 오래 걸리는 손님이 앞에 서 있으면 → 뒤에 있는 사람 전부 지연 (Convoy Effect)  
- 계산 빨리 끝나는 손님만 먼저 받으면 → 전체 줄이 빨리 빠짐 (SJF)  
- 손님 한 명씩 물건 몇 개만 계산하고 다음 사람으로 넘어가면 → RR

CPU 스케줄링도 결국 **“줄 서는 전략”**의 문제다.

---

## 3. 공식 개념 정의

### ✔ CPU 스케줄링(CPU Scheduling)

운영체제가 **준비 상태(Ready)인 프로세스/스레드들 중에서**  
어느 것을 골라 CPU에 할당할지 결정하는 정책과 알고리즘.

스케줄러는 보통 이런 목표를 균형 있게 고려한다:
- 평균 대기 시간 최소화
- 응답 시간 단축
- 전체 처리량(Throughput) 극대화
- 공정성(Fairness) 확보
- 특정 작업 우선 처리(Priority 반영)

실제로는 “하나의 완벽한 알고리즘”이 존재하는 게 아니라,  
**시스템 특성에 맞게** 여러 알고리즘을 조합해서 사용한다.

---

## 4. 구조로 이해하기 (큐와 Burst 관점)

CPU 스케줄링을 구조적으로 보면 다음 흐름으로 볼 수 있다.

1. 프로그램이 실행 요청 → 프로세스/스레드 생성  
2. 준비가 끝난 작업들은 **Ready Queue**에 줄을 섬  
3. **CPU 스케줄러**가 Ready Queue에서 하나를 선택  
4. 선택된 작업이 CPU에서 **CPU Burst**(계산)를 수행  
5. I/O가 필요하면 -> I/O 대기 큐로 이동  
6. I/O가 끝나면 다시 Ready Queue로 복귀

여기서 알고리즘마다 **Ready Queue에서 “누굴 뽑을 것인지” 기준**이 달라진다.

- FCFS: 가장 먼저 온 작업  
- SJF: 예상 CPU Burst가 가장 짧은 작업  
- Priority: 우선순위 숫자가 높은 작업  
- RR: 큐의 맨 앞 작업을 일정 시간만 실행 후 맨 뒤로

정리하면, CPU 스케줄링은  
> “Ready Queue에서 다음에 CPU를 쓸 대상을 고르는 룰셋”이라고 보면 된다.

---

## 5. 동작 원리 (알고리즘별 핵심 동작)

### ✔ 1) FCFS (First Come, First Served)

- **동작**: Ready Queue에 들어온 순서대로 그대로 실행  
- **특징**
  - 구현이 가장 간단  
  - 비선점(Non-preemptive): 한 번 CPU를 잡으면 스스로 끝내거나 I/O로 빠질 때까지 계속 사용  
- **문제**
  - 앞에 **긴 작업 하나**가 서 있으면 뒤에 있는 짧은 작업들이 전부 기다려야 함 → **Convoy Effect**

---

### ✔ 2) SJF (Shortest Job First)

- **동작**: 예상 CPU Burst가 가장 짧은 작업부터 실행  
- **특징**
  - 이론적으로 평균 대기 시간이 가장 짧은 알고리즘  
  - 비선점형 SJF, 선점형 SRTF(Shortest Remaining Time First) 두 종류가 있음  
- **문제**
  - “앞으로 이 작업이 얼마나 CPU를 쓸지” 예측해야 함  
  - 실제 시스템에서는 과거 기록을 기반으로 **예측값**을 사용

---

### ✔ 3) Priority Scheduling

- **동작**: 우선순위가 높은 프로세스부터 실행  
- **특징**
  - 비선점/선점 모두 가능  
  - 시스템 프로세스나 긴급 작업에 높은 우선순위를 줄 수 있음  
- **문제 (Starvation)**
  - 낮은 우선순위 작업이 **계속 뒤로 밀려서 영원히 실행되지 않는 상황** 발생  
  - 해결책: 오랫동안 기다린 작업의 우선순위를 점점 올리는 **Aging** 기법 사용

---

### ✔ 4) Round Robin (RR)

- **동작**: Ready Queue에서 작업을 하나 꺼내 **time slice(quantum)** 동안만 실행,  
  시간이 끝나면 강제로 CPU를 빼앗고 큐의 맨 뒤로 보냄.
- **특징**
  - 선점형 알고리즘  
  - 모든 작업이 CPU를 조금씩 공평하게 나눠 쓰게 됨  
  - 응답 속도가 중요할 때 좋은 선택  
- **문제**
  - time slice가 너무 짧으면 **context switching**이 너무 자주 발생  
  - 너무 길면 사실상 FCFS와 비슷해짐

time slice를 어디에 두느냐가 성능과 응답성을 가르는 **핵심 변수**다.

---

## 6. 실제 컴퓨터 내부에서는 어떤 일이 일어나는가?

- CPU는 한 순간에 **하나의 스레드**만 실행한다. (코어 하나 기준)  
- OS는 타이머 인터럽트를 걸어 두고,  
  - 일정 시간이 지나면 인터럽트를 발생시켜  
  - 현재 실행 중인 스레드의 상태(레지스터, PC 등)를 저장하고  
  - 다음에 실행할 스레드의 상태를 복원한다.  
- 이 상태 저장/복원 작업이 바로 **컨텍스트 스위칭**이고, 꽤 비싼 연산이다.  
- 스케줄러는 매번 Ready Queue를 보고  
  - FCFS/SJF/Priority/RR 규칙에 맞게  
  - “다음에 CPU를 누구에게 줄지”를 결정한다.

우리가 눈으로 볼 수 있는 “런큐 길이”, “context switch/sec” 같은 지표들은  
이 내부 동작이 **얼마나 자주, 얼마나 꼬여 있는지**를 숫자로 보여주는 것에 가깝다.

---

## 7. 백엔드 실무에서 왜 중요한가?

실무에서 이런 상황은 전부 CPU 스케줄링과 연결된다.

- 서버가 갑자기 느려질 때  
  - CPU 사용률, 런큐 길이, context switching 횟수를 보고  
  - “지금은 CPU가 과부하인지, I/O 대기인지, 스레드가 너무 많은지”를 판단해야 한다.
- 스레드 풀을 설계할 때  
  - CPU 바운드 작업 vs I/O 바운드 작업에 따라 적절한 스레드 수가 달라진다.  
  - 이것도 결국 CPU 스케줄링과 컨텍스트 스위칭 비용을 이해해야 설정할 수 있다.
- JVM·GC 튜닝  
  - GC 스레드가 CPU를 얼마나 쓰는지, 다른 애플리케이션 스레드와 어떤 식으로 경쟁하는지  
  - OS 스케줄링을 이해해야 전체 그림이 보인다.
- 컨테이너·클라우드 환경  
  - CPU 제한이 걸린 환경(Docker, K8s)에서 어떤 스케줄링 결과가 나올지 예측할 수 있어야 한다.

결국, **“스레드만 많이 쓰면 비동기니까 빠르다”**가 아니라,  
“OS 입장에서 이 스레드들이 어떻게 CPU를 나눠 쓰고 있는지”까지 보는 눈을 길러주는 개념이다.

---

## 8. 자주 하는 오해 vs 진실

### ❌ 오해 1: CPU는 여러 스레드를 동시에 실행한다
→ ✔ (코어 하나 기준) 한 순간에는 **하나의 스레드만 실행**한다.  
멀티코어라면 그 수만큼 병렬 실행이 가능할 뿐, 각각은 여전히 스케줄링 대상이다.

---

### ❌ 오해 2: 스레드를 많이 만들면 항상 더 빠르다
→ ✔ 스레드가 많아질수록 컨텍스트 스위칭 비용이 증가하고,  
락 경쟁까지 겹치면 오히려 전체 성능이 떨어질 수 있다.

---

### ❌ 오해 3: RR은 항상 공정하다
→ ✔ time slice 설정이 너무 크거나 작으면  
특정 작업이 체감상 더 불리해질 수도 있다.  
“공정하게 보이게 만드는 파라미터 튜닝”이 필요하다.

---

### ❌ 오해 4: SJF는 이론적으로 최고니까 실무에서도 최고다
→ ✔ 실제 서비스에서는 작업의 정확한 실행 시간을 모른다.  
대부분 과거 평균치로 **예측**할 뿐이고, 항상 맞는 것도 아니다.

---

## 9. 핵심 원리·구조·키워드 10줄 요약

1. CPU 스케줄링은 Ready Queue에서 “다음에 실행할 작업”을 고르는 정책이다.  
2. FCFS는 도착 순서대로 처리하지만 Convoy Effect 문제가 있다.  
3. SJF는 평균 대기 시간이 가장 짧지만 CPU Burst 시간을 예측해야 한다.  
4. Priority 스케줄링은 기아(starvation) 문제가 있고, Aging으로 완화한다.  
5. Round Robin은 time slice 기반 선점형 스케줄링이다.  
6. time slice 크기는 응답 시간과 context switching 비용의 트레이드오프다.  
7. 스케줄링은 타이머 인터럽트 + 컨텍스트 스위칭으로 구현된다.  
8. CPU는 코어 하나당 한 순간에 하나의 스레드만 실행한다.  
9. 스레드를 많이 만든다고 항상 성능이 좋아지는 것은 아니다.  
10. 서버 성능 튜닝과 장애 분석의 핵심 배경 지식이 바로 CPU 스케줄링이다.
