# Day07 – 캐시 & 지역성 (Questions)

# 1. 기본 질문 (Basic)
---

### **Q1. 캐시(Cache)란 무엇인가요?**
**A.**  
“캐시는 CPU가 자주 사용할 것 같은 데이터를  
미리 저장해 두는 매우 빠른 메모리입니다.  
메모리에 직접 접근하는 것보다 수십 배 이상 빠르기 때문에  
캐시 히트율이 높을수록 프로그램이 빠르게 동작합니다.”

---

### **Q2. 지역성(Locality)란 어떤 개념인가요?**
**A.**  
“지역성은 프로그램이 데이터를 사용하는 패턴을 의미하는데,  
보통 ‘같은 데이터는 반복적으로 사용되고(시간 지역성),  
가까운 주소의 데이터도 함께 사용될 확률이 높다(공간 지역성)’는 성질을 말합니다.  
캐시는 이 지역성 원리를 활용해 성능을 극대화합니다.”

---

### **Q3. 시간 지역성과 공간 지역성을 각각 설명해주세요.**
**A.**  
“시간 지역성은 ‘최근에 사용한 데이터는 다시 사용할 가능성이 높은 성질’을 의미합니다.  
반복문에서 특정 변수를 계속 접근하는 경우가 대표적입니다.  

공간 지역성은 ‘어떤 주소를 사용하면 그 주변 주소도 곧 사용할 가능성이 높은 성질’입니다.  
배열을 순차적으로 접근할 때 공간 지역성이 극대화됩니다.”

---

# 2. 중급 질문 (Intermediate)
---

### **Q4. 배열(Array) 접근이 왜 캐시 친화적이라고 하나요?**
**A.**  
“배열은 메모리에 연속적으로 저장되어 있기 때문에  
하나의 캐시 라인을 가져오면 그 안에 연속된 여러 요소가 함께 들어옵니다.  
따라서 순차적으로 접근할 경우 계속 캐시 히트가 발생해 매우 빠르게 동작합니다.”

---

### **Q5. 링크드 리스트가 배열보다 느린 이유는 무엇인가요?**
**A.**  
“링크드 리스트는 각 노드가 메모리에 흩어져 있기 때문에  
하나의 노드를 접근해도 그 근처에 다음 노드가 있을 가능성이 낮습니다.  
즉 공간 지역성이 떨어져 캐시 미스가 자주 발생하고,  
그 결과 동일한 연산이라도 훨씬 느리게 동작합니다.”

---

# 3. 심화 질문 (Advanced)
---

### **Q6. 캐시 라인(Cache Line)이 왜 중요한가요?**
**A.**  
“캐시는 데이터를 1바이트 단위가 아니라 ‘캐시 라인’이라는 덩어리로 가져옵니다.  
대부분의 CPU는 64바이트 단위로 메모리를 읽어 오는데,  
이 단위가 바로 캐시 라인입니다.  

따라서 어떤 주소를 접근하면 주변 63바이트가 함께 캐시에 올라오기 때문에  
공간 지역성이 좋은 코드는 캐시 효율이 매우 높아지는 반면,  
불규칙 접근 코드는 캐시 라인을 계속 교체하게 되어 성능이 떨어집니다.”

---

### **Q7. 캐시 미스가 많아지면 어떤 일이 벌어지나요?**
**A.**  
“캐시에 없어서 메모리에서 데이터를 가져와야 하기 때문에  
CPU는 그동안 idle 상태가 되고,  
실제 작업보다 기다리는 시간이 더 길어집니다.  
캐시 미스가 누적되면 전체 프로그램 성능이 급격히 떨어지고  
반복문 하나만 바꿔도 성능 차이가 크게 나는 이유도  
바로 캐시 미스 비율 차이 때문입니다.”

---

# 4. 꼬리질문 (Follow-up)
---

### **Q8. 현대 CPU는 캐시 미스를 줄이기 위해 어떤 전략을 사용하나요?**
**A.**  
“현대 CPU는 하드웨어 기반 ‘프리페치(prefetch)’ 로직을 사용해  
미리 데이터를 가져와 캐시에 올려놓습니다.  
예를 들어 배열을 순차적으로 접근하는 패턴을 CPU가 감지하면  
앞으로 사용할 주소를 미리 예측해 읽어두는 방식입니다.  
이 덕분에 캐시 미스 비율을 낮추고 성능을 높일 수 있습니다.”

---

### **Q9. L1/L2/L3 캐시가 왜 여러 단계로 나뉘어 있나요?**
**A.**  
“캐시가 빠르려면 작아야 하고,  
크려면 상대적으로 느려져야 하는 구조적 한계가 있기 때문입니다.  
그래서 작은 용량의 초고속 L1 캐시,  
조금 느리지만 더 큰 L2 캐시,  
모든 코어가 공유하는 L3 캐시로 계층을 나누어  
속도와 용량을 균형 있게 구성합니다.”

---

# 5. 실무 질문 (Practical)
---

### **Q10. GC와 CPU 캐시가 어떻게 관련이 있나요?**
**A.**  
“GC가 객체를 이동시키거나 해제하는 과정에서  
메모리 배치의 연속성이 깨질 수 있습니다.  
객체가 여기저기 흩어지면 공간 지역성이 떨어지고  
CPU 캐시 효율이 낮아집니다.  
그래서 JVM의 다양한 GC 알고리즘이 ‘객체를 연속적으로 배치하려고 노력하는 이유’가  
바로 캐시 효율 때문입니다.”

---

### **Q11. 서버는 CPU가 충분한데 왜 응답이 느릴 수 있나요?**
**A.**  
“스레드가 CPU를 쓰지 못해서가 아니라  
캐시 미스로 인해 메모리 접근을 기다리는 시간 때문에 느린 경우가 많습니다.  
즉 CPU는 놀고 있지만, 필요한 데이터가 메모리에서 아직 안 올라왔기 때문에  
실행할 수 없어서 응답이 늦어지는 것입니다.”

---

# 6. 비교 질문 (Comparison)
---

### **Q12. 시간 지역성 vs 공간 지역성 비교해주세요.**
**A.**  
“시간 지역성은 ‘최근에 사용한 데이터는 다시 사용할 가능성이 높다’,  
공간 지역성은 ‘가까운 주소의 데이터도 사용할 가능성이 높다’는 성질입니다.  
둘 다 캐시 히트율을 높이는 핵심 원리입니다.”

---

### **Q13. 캐시 구조와 메모리 구조의 차이를 한 문장으로 설명해주세요.**
**A.**  
“캐시는 CPU가 빠르게 접근하기 위한 초고속 저장소이고,  
메모리는 용량이 크지만 상대적으로 느린 주 기억장치입니다.”
