# [11단계] 추상 클래스 (abstract class)

> "공통의 뼈대만 정의하고, 구체적인 내용은 자식에게 맡긴다"
> 
> 
> 바로 **추상 클래스와 추상 메서드의 세계**야!
> 

---

### 💡 핵심 개념 요약

| 개념 | 설명 |
| --- | --- |
| `abstract class` | **추상 클래스**. 직접 객체 생성은 불가능하고, 자식 클래스가 상속받아 사용 |
| `abstract method` | **추상 메서드**. 몸통(구현부)이 없고, 자식 클래스가 반드시 오버라이딩 |
| 목적 | 공통 인터페이스 제공 + 자식 클래스에게 구현 강제 |
| 특징 | 일반 메서드 + 추상 메서드를 모두 가질 수 있음 |

---

### 🧾 예시 코드

```java
// 추상 클래스
abstract class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    abstract void speak(); // 자식이 반드시 오버라이딩할 메서드

    void introduce() {
        System.out.println("안녕하세요, 저는 " + name + "입니다.");
    }
}

// 자식 클래스
class Dog extends Animal {
    Dog(String name) {
        super(name);
    }

    void speak() {
        System.out.println("멍멍!");
    }
}
```

---

### 📌 포인트 요약

- 추상 클래스는 **객체 생성 불가** → `new Animal()` ❌
- 추상 메서드는 **자식 클래스에서 반드시 구현**해야 함
- `abstract` 클래스 안에는 **일반 메서드도 함께 존재 가능**
- 자식 클래스가 추상 메서드를 오버라이딩하지 않으면 **컴파일 에러 발생**

---

### 🧪 실습 미션

> ✅ 다음 요구사항에 맞게 추상 클래스를 활용한 코드를 작성해보자!
> 
1. `abstract class Animal` 정의
    
    → 필드: `String name`, 메서드: `abstract void speak()`, `void introduce()`
    
2. `Dog`, `Cat` 클래스는 `Animal`을 상속
3. 각각 `speak()` 오버라이딩
4. `Main`에서 `Dog`와 `Cat` 객체 생성 후 `introduce()`와 `speak()` 호출

✅ 출력 예시:

```
안녕하세요, 저는 아부입니다.
멍멍!
안녕하세요, 저는 나비입니다.
야옹~
```

---

## ❔ 질문 정리

---

### ❓ 자식 클래스에서 `name` 필드를 따로 정의하지 않는 이유?

✅ 자식 클래스는 **부모 클래스의 필드/메서드를 그대로 상속받기 때문!**

```java
java
복사편집
Dog dog = new Dog("아부");
System.out.println(dog.name); // ✅ 가능

```

❗ 자식 클래스에서 `String name;`을 다시 선언하면

**부모와 자식 각각 따로 존재 → 혼란과 버그 발생 위험!**

---

### ❓ 부모 클래스에는 반드시 생성자를 명시해야 하나요?

| 상황 | 부모 생성자 필요 여부 |
| --- | --- |
| 생성자를 아무것도 안 만들었을 때 | ❌ 기본 생성자 자동 생성됨 |
| 생성자를 하나라도 만들었을 때 | ✅ 자식이 쓰려면 `super(...)` 필수 호출 |
| 자식에서 `super(...)` 호출할 거면? | ✅ 부모 생성자 있어야 함 |

> 부모에 생성자를 정의하면 기본 생성자는 자동 생성되지 않음!
> 
> 
> 따라서 `super(name)` 같은 명시 호출이 필수야.
>