# Day01-2 — 1부터 N까지의 합 (Sum to N)

> 📆 Date: 2025-10-16
> 
> 
> ⏱ 설계 / 구현 / 디버그: 1m / 2m / 1m
> 
> 💬 난이도: Lv1
> 
> 🧭 Phase: 0
> 
> 🔁 복습일: D+3
> 

---

## 🧩 문제 설명

자연수 `N`이 주어졌을 때,

1부터 N까지의 모든 자연수의 합을 구하는 프로그램을 작성하시오.

**입력 예시**

```
5
```

**출력 예시**

```
15
```

---

## 💡 핵심 개념 요약

- **반복문(`for`)**: 코드를 여러 번 반복 실행할 때 사용한다.
예: `for (int i = 1; i <= N; i++)`
- **누적합(`sum`)**: 이전까지의 합에 새로운 값을 계속 더해가는 변수.
예: `sum += i;`
- 알고리즘 기본 흐름: **입력 → 반복 → 누적 → 출력**
- 누적합은 알고리즘 전반에서 매우 자주 등장하는 기본 패턴.
(나중에 Prefix Sum, DP로 확장됨)

---

## 🧾 문제 풀이

### ✏️ 내 풀이

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
				int sum = 0;
				
        for (int i = 1; i <= n; i++) {
				    sum += n;    
        }
        
        System.out.println(sum);
    }
}
```

### 💎 온이 풀이

```java
import java.util.Scanner;

public class MainOni {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int sum = 0;

        // ✅ 핵심 로직: i를 1부터 n까지 순차적으로 더하기
        for (int i = 1; i <= n; i++) {
            sum += i;
        }

        System.out.println(sum);
    }
}
// ✅ 전략: 반복문을 이용한 누적합 (sum += i)
// ⏱ 시간복잡도: O(n)
// 💬 포인트: 누적 변수(sum)를 매 루프마다 업데이트하는 기본 패턴
```

### 📌 비교 포인트

| 항목 | 새봄 코드 | 온이 코드 | 차이 |
| --- | --- | --- | --- |
| 입력 처리 | `Scanner`로 `n` 입력 | 동일 | 동일 |
| 누적 변수 | `sum = 0` | 동일 | 동일 |
| 반복문 구조 | `for (int i = 1; i <= n; i++)` | 동일 | 동일 |
| 누적 대상 | `sum += n;` | ✅ `sum += i;` | 핵심 차이 — i를 더해야 1부터 n까지의 합이 됨 |
| 출력 | `System.out.println(sum);` | 동일 | 동일 |
| 시간 복잡도 | O(n) | O(n) | 동일 |
| 로직 목적 | 누적 구조 정확히 구현 | ✅ 완전한 누적 합 구조 | i/n 혼동 외에는 완벽 |

---

## 🌱 핵심 정리

- **핵심 문법:** `for`, `+=`, 누적 변수(`sum`)
- **핵심 구조:** 입력 → 반복 → 누적 → 출력
- **시간 복잡도:** O(n)
- **학습 포인트:**
    - 반복문은 **동일한 규칙을 여러 번 수행하는 제어 구조**
    - 누적합(`sum += i;`)은 알고리즘 전반의 기본 패턴
    - 이 구조는 이후 **배열의 합 / 구간합 / 누적 평균 / Prefix Sum / DP** 등으로 확장된다.
    - `sum`을 초기화하지 않으면 Garbage 값이 누적되므로 항상 `sum = 0`부터 시작해야 한다.

> 💬 온이 코멘트:
> 
> 
> 이번 단계의 목표는 단순히 “for문을 쓴다”가 아니라,
> 
> “반복되는 규칙을 머릿속에서 먼저 패턴화할 수 있는 사고”를 익히는 거야.
> 

---

## 📒 이해 확장 질문

### 💬 **Q1.** `sum += i;` 대신 `sum = sum + i;` 로 써도 될까?

→ ✅ 완전히 동일한 의미야.

`+=` 는 단축 대입 연산자라서, `sum = sum + i;` 를 간결하게 줄인 문법일 뿐이야.

---

### 💬 **Q2.** 반복 범위가 `i < n`이면 어떻게 될까?

→ 마지막 값 `n`이 더해지지 않아.

예를 들어 `n = 5`일 때

`1 + 2 + 3 + 4 = 10` 이 되어, 최종 결과가 하나 빠져버려.

→ 그래서 **“포함해야 하는 범위 끝값”은 항상 `<=` 로 지정**해야 한다.

---

### 💬 **Q3.** `while`문으로도 똑같이 구현할 수 있을까?

→ 가능해! 아래처럼 구조만 바뀌고 결과는 동일해 👇

```java
int i = 1;
while (i <= n) {
    sum += i;
    i++;
}
```

→ 핵심은 **“i가 1부터 n까지 증가하며 sum에 더해진다”** 는 논리가 그대로 유지된다는 점이야.

즉, **for와 while은 사고 구조는 같고, 표현만 다르다.**

---

### 💬 **Q4.** 수학 공식으로 풀면 반복문 없이도 계산할 수 있을까?1+2+...+n=2n(n+1)

→ 가능하지!

**가우스 공식:**

1+2+...+n=n(n+1)21 + 2 + ... + n = \frac{n(n + 1)}{2}

그래서 이렇게도 가능해 👇

```java
int sum = n * (n + 1) / 2;

```

→ 하지만 우리는 지금 **반복문 구조를 손에 익히는 단계**라,

수학식보다 **반복 흐름을 이해하는 게 우선**이야 💪

---

> 💬 온이 코멘트:
> 
> 
> “하나의 문제를 여러 각도에서 바라보는 사고”가
> 
> 나중에 알고리즘 선택(반복, 재귀, 수식, 누적 등)에 큰 영향을 줘.
> 
> 이번 섹션이 바로 그 사고의 첫 훈련이야 🌱
> 

---

## 🐞 실수 체크

| 구분 | 실수 내용 | 원인 | 교정 방법 |
| --- | --- | --- | --- |
| **로직** | `sum += n` 으로 작성 | 반복 인덱스 `i` 대신 `n` 사용 | **“누적은 i다.”** 를 입으로 말하면서 코딩하기 |
| **초기화** | `sum` 초기화 누락 | 변수의 초기값 개념 미숙 | 항상 `int sum = 0;` 부터 시작 |
| **조건문** | `i < n` 으로 작성 | 등호 누락 (`<=`) | 범위 끝값 포함 여부를 항상 말로 검증 (“1부터 n까지”) |
| **변수명** | `i` 대신 `n` 혼용 | 루프 변수/입력 변수 혼동 | i = loop, n = input 명확히 분리 |
| **출력** | println 생략 | 디버깅 과정에서 빠뜨림 | 실행 후 반드시 출력 확인 |

> 💬 온이 코멘트:
> 
> 
> “for문은 단순 반복이 아니라 패턴 누적의 사고 구조야.
> 
> 이 단계에서의 실수는 대부분 ‘변수의 역할 구분’에서 발생해.”
> 
> → 앞으로 i, n, sum 이 세 변수를 “역할이 다른 팀원”처럼 분리해서 생각해보자 🌱
> 

---

## 🔁 리마인드

> “반복문은 **규칙적인 변화를 코드로 표현하는 도구**다.”
입력이 달라도 흐름은 항상 **입력 → 반복 → 누적 → 출력**으로 이어진다.
`sum += i;` 는 단순한 연산이 아니라, **‘이전 상태를 기억하고 다음 상태를 만드는 사고 구조’** 다.
이 한 줄이 익숙해지면, 나중에 **배열 합 → 구간합 → Prefix Sum → DP(동적 계획법)** 으로 자연스럽게 이어진다. 🌱
>