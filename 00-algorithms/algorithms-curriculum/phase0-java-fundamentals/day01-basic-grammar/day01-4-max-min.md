# Day01-4 — 최댓값 / 최솟값 (Max / Min)

> 📆 Date: 2025-10-15
⏱ 설계 / 구현 / 디버그: 1m / 3m / 4m
> 
> 
> 💬 난이도: Lv1
> 
> 🧭 Phase: 0
> 

---

## 🧩 문제 설명

정수 N개가 주어졌을 때,

그 중 **최댓값과 최솟값**을 구하는 프로그램을 작성하시오.

**입력 예시**

```
5
3 7 2 9 4
```

**출력 예시**

```
최댓값: 9
최솟값: 2
```

---

## 💡 핵심 개념 요약

- **비교 갱신 패턴:**
반복하면서 새로운 값이 기존보다 크거나 작으면 변수 갱신.
    
    ```java
    if (num > max) max = num;
    if (num < min) min = num;
    ```
    
- **초기화 중요:**
    - 첫 번째 입력값으로 `max`, `min` 초기화
    - 이후 두 번째 값부터 비교 시작
- **Math 클래스 활용:**`Math.max(a, b)`, `Math.min(a, b)` 로도 가능.
- **반복 구조:**
입력 개수만큼 `for`문 반복하며 비교.

---

## 🧾 문제 풀이

### ✏️ 내 풀이

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
				sc.nextLine();
				String str = sc.nextLine();
				String[] arr = str.split(" ");
				int min = Integer.parseInt(arr[0]);
				int max = Integer.parseInt(arr[0]);
				
				for (int i = 1; i < n; i++) {
						int num = Integer.parseInt(arr[i]);
						if (num > max) max = num;
						if (num < min) min = num;
				}
				
				System.out.println("최댓값: " + max);
				System.out.println("최솟값: " + min);
				
    }
}
```

### 💎 온이 풀이

```java
import java.util.Scanner;

public class MainOni {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            int num = sc.nextInt();
            if (num > max) max = num;
            if (num < min) min = num;
        }

        System.out.println("최댓값: " + max);
        System.out.println("최솟값: " + min);
    }
}
```

### 📌 비교 포인트

| 항목 | 새봄 코드 | 온이 코드 | 차이 |
| --- | --- | --- | --- |
| 입력 방식 | 한 줄 입력 후 split | 반복 입력 | ✅ 문자열 입력 처리로 확장성↑ |
| 초기화 | 첫 원소 기준 | `Integer.MIN/MAX_VALUE` | ✅ 실무에서 더 안정적 |
| 반복 시작 | i = 1 | i = 0 | ✅ 첫 원소로 초기화했으니 i=1 적절 |
| 비교 구조 | 독립 if 2개 | 동일 | 동일 |
| 출력 | “최댓값: …” 형식 | 동일 | 동일 |

💡 새봄 버전은 “문자열 → 정수 배열 변환” 방식을 직접 구현했다는 점에서

입력 제어 감각이 확실히 잡혔다는 걸 보여줘! 👏

---

## 🌱 핵심 정리

- 비교 갱신 패턴의 기본 구조:
    
    ```
    초기화 → 반복 → 조건 비교 → 갱신
    ```
    
- 초기값 설정은 상황에 따라 다르게(첫 원소 기반 / 상한값 기반)
- 조건문은 반드시 **두 개의 독립 if문**
- 시간 복잡도: O(n)
- 실수 위험 구간: 초기화 / 비교 방향 / 입력 인덱스

---

## 📒 이해 확장 질문

### 💬 **Q1. Math 클래스로 바꿔서 구현할 수 있을까?**

→ ✅ 가능해.

`max = Math.max(max, num);`

`min = Math.min(min, num);`

이런 식으로 쓰면 if문을 한 줄로 축약 가능.

→ 단, 반복문 안에서 수백만 번 호출 시 약간의 오버헤드 발생.

---

### 💬 **Q2. 입력이 모두 음수일 때도 잘 동작할까?**

→ ✅ 새봄 코드에서는 첫 번째 값으로 초기화했기 때문에 문제없어.

→ `Integer.MIN_VALUE` 초기화 버전도 안전하지만,

“첫 값 기반 초기화”는 입력 범위를 몰라도 안정적이야.

---

### 💬 **Q3. max와 min을 동시에 구할 수 있을까?**

→ ✅ 가능.

현재 코드처럼 한 번의 반복에서 둘 다 검사하면

O(n) 안에 둘 다 얻을 수 있어.

(굳이 두 번 순회할 필요 없음)

---

### 💬 **Q4. 배열 없이 바로 처리할 수 있을까?**

→ ✅ 가능해.

입력값을 `for`문으로 한 개씩 바로 받으면

메모리를 덜 쓰고 코드도 단순화돼.

(온이 풀이 방식이 바로 그거야)

---

> 💬 **온이 코멘트:**
최댓값·최솟값 문제는 단순 계산이 아니라
**비교의 흐름을 제어하는 사고 구조**를 배우는 단계야.
이 감각이 익숙해지면, 나중에
“최대 누적합”, “최소 거리”, “가장 빠른 시간” 같은 문제로 자연스럽게 확장돼 🌱
> 

---

## 🐞 실수 체크

| 구분 | 실수 내용 | 원인 | 교정 방법 |
| --- | --- | --- | --- |
| 입력 처리 | `nextInt()` 뒤 개행 미처리 | 버퍼에 남은 `\n` 처리 누락 | `sc.nextLine()` 추가로 개행 제거 |
| 초기화 | `max/min`을 0으로 초기화 | 입력이 모두 음수일 경우 오류 | 첫 번째 입력값으로 초기화 |
| 비교 조건 | `>` / `<` 방향 혼동 | 조건식 방향 헷갈림 | “크면 max, 작으면 min”을 입으로 확인 |
| 루프 범위 | `i <= n` 사용 | 인덱스 초과 발생 | `i < n` 로 고정 |
| 출력 포맷 | `println(max + " " + min)`만 출력 | 문제 요구 형식과 다름 | 문제 요구 포맷을 항상 확인 |

> 💬 **온이 코멘트:**
최댓값·최솟값 문제는 간단하지만, “초기화”와 “조건 방향”이 헷갈리면 실무에서도 종종 버그를 만든다.
특히 음수 입력, 한 줄 입력 형태에서는 입력 버퍼와 초기화 방식을 항상 함께 고려하자 🌱
> 

---

## 🔁 리마인드

> “비교 갱신은 ‘기준을 세우고, 새로 들어온 값으로 갱신하는 과정’이다.”
> 
- 루프는 단순 반복이 아니라 “기준 검증”을 위한 구조다.
- `max`, `min`은 매번 새로운 입력값과의 **관계 판단자** 역할을 한다.
- 다음번 비슷한 문제를 만나면,
    
    머릿속에서 이렇게 흐름을 그리자 👇
    
    ```
    초기값 설정 → 반복 → 비교 → 갱신 → 출력
    ```
    
- 이 한 패턴이 익숙해지면
    
    👉 “최대 합”, “최소 거리”, “최소 비용” 문제로 그대로 확장 가능!