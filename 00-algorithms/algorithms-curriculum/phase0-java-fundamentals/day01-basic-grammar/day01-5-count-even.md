# Day01-5 — 짝수 개수 세기 (Count Even)

> 📆 Date: 2025-10-15
> 
> 
> ⏱ 설계 / 구현 / 디버그: 1m / 2m / 1m
> 
> 💬 난이도: Lv1
> 
> 🧭 Phase: 0
> 

---

## 🧩 문제 설명

정수 N개가 주어졌을 때,

그 중 **짝수의 개수**를 구하는 프로그램을 작성하시오.

**입력 예시**

```
5
3 6 8 1 10
```

**출력 예시**

```
짝수 개수: 3
```

---

## 💡 핵심 개념 요약

- **짝수 판별:** `n % 2 == 0` → 짝수, `n % 2 != 0` → 홀수
- **카운팅 패턴:** 조건이 참일 때마다 `count++`
- **초기화:** `count`는 0으로 시작
- **반복 구조:** 입력받은 수 N개를 반복하면서 조건문으로 짝수 여부 확인

---

## 🧾 문제 풀이

### ✏️ 내 풀이

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        
        String str = sc.nextLine();
        String[] arr = str.split(" ");

				int cnt = 0;
				
				for (int i = 0; i < arr.length; i++) {
						int num = Integer.parseInt(arr[i]);
						
						if (num % 2 == 0) {
								cnt++;
						}
				}
				
				System.out.println("짝수 개수: " + cnt);
				
    }
}
```

### 💎 온이 풀이

```java
import java.util.Scanner;

public class MainOni {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int count = 0;
        for (int i = 0; i < n; i++) {
            int num = sc.nextInt();
            if (num % 2 == 0) count++;
        }

        System.out.println("짝수 개수: " + count);
    }
}
// ✅ 전략: 입력 즉시 판단하는 실시간 카운트 방식
// ⏱ 시간복잡도: O(n)
```

### 📌 비교 포인트

| 항목 | 새봄 코드 | 온이 코드 | 차이 |
| --- | --- | --- | --- |
| 입력 방식 | 한 줄 입력 + split | 반복 입력 | ✅ 문자열 입력 처리로 확장성↑ |
| 루프 범위 | arr.length | n | 동일 (입력 길이 일치 시) |
| 조건식 | num % 2 == 0 | 동일 | 동일 |
| 변수명 | cnt | count | 가독성 차이만 있음 |
| 출력 | `"짝수 개수: " + cnt` | 동일 | 동일 |

> 💬 **온이 코멘트:**
새봄 버전은 **문자열 처리 기반의 유연형** 코드라
다양한 입력 패턴에 대응 가능하고,
온이 버전은 **입력 즉시 처리형**으로 메모리를 아끼는 구조야.
> 

---

## 📒 이해 확장 질문

### 💬 **Q1. 홀수 개수를 세려면?**

→ `if (num % 2 != 0)` 또는 `if (num % 2 == 1)`

→ 조건만 반대로 바꾸면 됨.

💡 **짝/홀 조건은 항상 “2로 나눈 나머지” 중심**으로 판단한다.

---

### 💬 **Q2. 배열 없이 바로 처리할 수 있을까?**

→ ✅ 가능!

입력마다 바로 짝수 여부를 검사해서 count++ 하면 된다.

(온이 풀이 방식이 이거야)

→ 이렇게 하면 메모리도 절약되고 실시간 판단이 가능하지.

---

### 💬 **Q3. while문으로도 구현할 수 있을까?**

→ ✅ 가능!

```java
int i = 0;
while (i < n) {
    int num = sc.nextInt();
    if (num % 2 == 0) cnt++;
    i++;
}
```

→ for문과 구조는 동일하지만,

while은 **증감 조건**을 직접 관리해야 한다.

---

### 💬 **Q4. count++ 대신 count += 1 로 써도 되나?**

→ ✅ 완전히 같아.

둘 다 1씩 증가시키는 표현이고,

`++`은 단축 연산자일 뿐이야.

---

> 💬 **온이 코멘트:**
“count 패턴은 단순하지만,
실제 알고리즘에서는 빈도, 개수, 조건 만족 횟수 등 거의 모든 누적에 쓰여.”
이 한 줄(`if (조건) count++;`)이 나중에
**투포인터, 슬라이딩 윈도우, 브루트포스 탐색**의 기본 루프가 돼 🌱
> 

---

## 🐞 실수 체크

| 구분 | 실수 내용 | 원인 | 교정 방법 |
| --- | --- | --- | --- |
| 입력 처리 | `nextInt()` 후 `nextLine()` 누락 | 개행 문자로 인한 입력 오류 | 항상 `sc.nextLine()` 추가 |
| 타입 변환 | `Integer.parseInt` 누락 | 문자열 배열 처리 시 변환 필수 | `int num = Integer.parseInt(arr[i]);` 확인 |
| 조건식 | `==` 대신 `=` 사용 | 비교 연산자 혼동 | `==`는 비교, `=`는 대입 |
| 루프 범위 | `i <= arr.length` | 인덱스 초과 오류 | 항상 `i < arr.length` |
| count 초기화 | `count` 초기화 누락 | 이전 값이 남아 잘못된 결과 | `int count = 0;` 기본 습관화 |

> 💬 **온이 코멘트:**
count++는 단순하지만, “조건 확인 → 증가 → 반복”의 세 단계를 완벽히 끊어 생각해야 한다.
이게 나중에 **조건 누적 / 합산 / 평균** 문제의 기초가 된다.
> 

---

## 🔁 리마인드

> “조건이 참일 때마다 누적한다 — count++ 패턴은 반복문의 심장이다.”
> 
- 반복은 데이터를 훑고,
- 조건은 필요한 것만 걸러내며,
- count++는 결과를 누적한다.

이 세 단계를 하나로 묶으면

“조건 누적 패턴”이라는 이름의 사고 틀이 완성돼.

이걸 완전히 익히면,

📘 이후 Phase1에서 **배열 탐색 / 투포인터 / 슬라이딩 윈도우** 문제까지

자연스럽게 이어질 거야 🌞