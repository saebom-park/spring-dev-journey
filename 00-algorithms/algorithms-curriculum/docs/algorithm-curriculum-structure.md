# Algorithm Curriculum Structure

> 이 문서는 `spring-dev-journey/00-algorithms/algorithms-curriculum` 폴더에  
> 상시 참조용으로 보관한다.  
>  
> 알고리즘 루틴 전체의 문서 포맷, 설명 방식, 학습 전략을 정의한다.

---

## 🧭 Ⅰ. 전체 개요

| 구분 | 설명 |
|------|------|
| **Phase 0** | 자바 문법 리빌드 구간 – 손코딩 기반 문법 체화 중심 |
| **Phase 1~5** | 알고리즘 개념 / 구현 / 사고력 중심 구간 – 교재형 개념 학습 중심 |
| **학습 포맷** | All-in-One 형식 (💡→🧾→📌→🌱→📒→🐞) |
| **작성 언어** | Java (손코딩 원칙) |

---

## 🌱 Ⅱ. Phase 0 — 자바 문법 리빌드 전용 포맷

### 🎯 목적
> 알고리즘 학습 이전에 Java 문법을 **손코딩 수준으로 완전 체화**  
> → “문법 고민 없이 구현할 수 있는 상태” 만들기

---

### 📘 Phase 0 구조

```
phase0-java-fundamentals/
├── day01-basic-grammar/
│   ├── day01-1-even-or-odd.md
│   ├── day01-2-sum-to-n.md
│   └── ...
├── day02-collections/
├── day03-string-math/
├── day04-io-method/
└── day05-mini-project/
```

---

### 🧩 포맷 구성 (간략형 All-in-One)

| 구간 | 내용 |
|------|------|
| 💡 **핵심 개념 요약** | 문법 요약 중심 (if, for, while, Scanner, 배열 등) |
| 🧾 **문제 풀이** | 직접 손코딩 / 기본 문법 실습 |
| 📌 **비교 포인트** | 코딩 스타일, 출력 방식 등 |
| 🌱 **핵심 정리** | 문법 총정리 / 대표 예제 |
| 📒 **질문** | 문법 헷갈린 점 (예: `%` 음수 결과) |
| 🐞 **실수** | 오타 / 괄호 누락 등 단순 문법 실수 |

---

### ✅ 특징 요약

| 항목 | 설명 |
|------|------|
| **학습 성격** | 문법 체화, 손코딩 반복 |
| **개념 깊이** | 얕음 (기억 중심) |
| **목표 수준** | `Scanner`, `for`, `if` 등 자유자재 활용 |

---

## 🚀 Ⅲ. Phase 1~5 — 교재형 알고리즘 학습 포맷

### 🎯 목적
> “이해 → 사고 → 구현 → 최적화” 단계까지  
> 온이 설명으로 **독학 가능한 교재형 학습** 완성  

---

### 📘 Phase 1~5 전체 구조

```
algorithms-curriculum/
│
├── phase1-implementation/           # 구현 / 수학 / 문자열
├── phase2-data-structure/           # 자료구조 / 정렬 / 그리디
├── phase3-graph-search/             # DFS / BFS / 백트래킹
├── phase4-advanced/                 # DP / 누적합 / 최적화
└── phase5-practice/                 # 실전 모의테스트
```

---

### 💡 핵심 개념 요약

#### 🧭 ① 개념 인트로 (직관적 비유 중심)
> “왜 이 개념이 필요한가”를 일상적 비유로 풀어서 설명  
> 예: “DFS는 미로 탈출처럼 끝까지 가보다가 막히면 돌아오는 사고 방식이다.”

#### 🧠 ② 개념 정의 및 조건
| 항목 | 설명 |
|------|------|
| 개념 정의 | 개념의 핵심 한 줄 요약 |
| 적용 조건 | 언제 이 알고리즘이 유효한가 |
| 검증 포인트 | 반례로 틀릴 가능성 여부 |
| 대표 문제 | 실습 예시 1~2개 |

#### ⚙️ ③ 시각적 흐름 (문제 해결 다이어그램)
```
문제 입력 → 탐욕 기준 설정 → 반복 선택 → 결과 계산
```

#### 💬 ④ 실전 사고 질문 (사고 훈련용)
- 탐욕 기준이 명확한가?  
- 선택 결과가 다음 선택에 영향을 주지 않는가?  
- 부분 최적해가 전체 최적해를 보장하는가?  

---

### 🧾 문제 풀이 (설명형)

#### 🧩 내 풀이
> 새봄이 직접 작성한 코드 (손코딩 기반)

#### 💎 온이 풀이
> 전략 / 시간복잡도 / 코멘트 포함한 교재형 해설 코드

```java
// ✅ 전략: 정렬 + 순차 탐색 (O(N log N))
// - 이유: 탐욕 선택 구조를 유지하기 위해 종료시간 기준 정렬
// - 시간복잡도: O(N log N)
```

#### 📈 코드 해석 흐름
1. 정렬  
2. 조건 선택  
3. 결과 누적  
4. 최적성 근거 설명  

---

### 📌 비교 포인트
> 내 코드와 온이 코드의 차이를 구체적으로 표로 비교

| 항목 | 내 코드 | 온이 코드 | 차이점 |
|------|----------|-----------|--------|
| 정렬 기준 | 시작 시간 | 종료 시간 | 탐욕 기준 차이 |

---

### 🌱 핵심 정리
- 핵심 로직 요약  
- 시간 복잡도  
- 실전 적용 패턴 정리  

---

### 📒 질문 (이해형)
- 이 문제는 다른 자료구조로도 풀 수 있을까?  
- 입력이 커지면 시간복잡도가 어떻게 될까?  

---

### 🐞 실수
- 정렬 기준 반대  
- 종료시간 업데이트 누락

---

### ✅ 특징 요약

| 항목 | 설명 |
|------|------|
| **학습 성격** | 교재형 (이론 + 문제 + 사고 훈련) |
| **개념 깊이** | 깊음 (이해 중심) |
| **목표 수준** | 알고리즘 사고력 + 코드 최적화 |