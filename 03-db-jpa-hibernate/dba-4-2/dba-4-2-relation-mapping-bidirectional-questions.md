# [DBA-4-2단계] 질문노트: 양방향 연관관계 매핑

> 💬 봄이가 직접 궁금해서 물어본 것들 + 온이의 설명 요약
> 
> 
> (코드: com.springlab17 실습 기준)
> 

---

### 💡 1. 단방향과 양방향 연관관계는 결국 Order가 Many고 Member가 One인 건 똑같은데, 뭐가 다른 거야?

| 질문 | 답변 요약 |
| --- | --- |
| 어차피 Order가 Many고 Member가 One인 건 똑같은데, 단방향과 양방향 개념은 뭐가 달라? | 단방향은 Order만 Member를 참조하고, Member는 자신이 가진 주문들을 모름. 양방향은 Member도 자신이 가진 Order 목록을 컬렉션으로 참조함. 즉, 양방향은 양쪽 모두 참조하는 구조이며, 연관관계의 방향이 다를 뿐 주인은 여전히 Order 쪽(`@ManyToOne`)이다. |

---

### 💡 2. 그럼 참조 방향이 단방향인지 양방향인지에 따라 테이블 구조도 달라져?

| 질문 | 답변 요약 |
| --- | --- |
| 객체 참조가 단방향이냐 양방향이냐에 따라 DB 테이블 구조도 바뀌는 거야? | ❌ 바뀌지 않음. 테이블 구조는 외래키 기준으로 생성되며, 외래키는 항상 `@ManyToOne` 쪽에만 존재. 단방향이든 양방향이든 `Order.member_id` 외래키 컬럼만 생성되고, `Member` 테이블은 그대로다. 차이는 오직 자바 객체 간 참조 방향일 뿐이다. |

---

### 💡 3. `@OneToMany(mappedBy = "member")`는 무슨 뜻이야?

| 질문 | 답변 요약 |
| --- | --- |
| `@OneToMany(mappedBy = "member")`는 정확히 무슨 의미야? | 이 애노테이션은 양방향 연관관계에서 **컬렉션을 가진 비주인 쪽**에 사용됨. 여기서 `mappedBy = "member"`는 "Order 엔티티 안에 있는 member 필드가 외래키를 관리하고 있다"는 뜻. 즉, `Order.member`가 연관관계의 주인이고, `Member.orders`는 단지 읽기 전용 컬렉션 필드라는 뜻이야. |

---

### 💡 4. 주인은 왜 정하는 거야?

| 질문 | 답변 요약 |
| --- | --- |
| 왜 연관관계의 주인을 반드시 정해야 해? | JPA는 연관된 두 객체 중 어떤 쪽을 기준으로 외래키를 DB에 반영할지 결정해야 하기 때문. 주인(`@ManyToOne`) 쪽만이 실제로 DB에 insert/update 쿼리를 실행할 수 있음. 반면 비주인(`@OneToMany(mappedBy)`)은 읽기 전용이라 DB에 영향을 주지 않음. 주인을 정하지 않으면 외래키가 저장되지 않거나, 정합성이 깨질 수 있음. |

---

### 💡 5. save()는 DB에 바로 저장하는 거야?

| 질문 | 답변 요약 |
| --- | --- |
| save()만 호출했는데 진짜 DB에 저장되는 거야? | ❌ 바로 저장되는 건 아님. save()는 객체를 영속성 컨텍스트에 등록만 하고, 실제 insert 쿼리는 flush 또는 commit 시점에 실행됨. 우리는 SQL을 직접 작성하지 않아도 되지만, 저장은 트랜잭션 종료 시에 일어남. |

---

### 💡 6. flush는 그럼 진짜 저장이야?

| 질문 | 답변 요약 |
| --- | --- |
| flush가 호출되면 진짜 DB에 insert 되는 거야? | ✅ 맞음. flush는 영속성 컨텍스트에 있는 내용을 SQL로 변환해서 실제 DB로 insert/update 쿼리를 전송함. 단, flush 후에도 트랜잭션이 rollback 되면 DB에는 반영되지 않음. |

---

### 💡 7. 단방향에서는 save만 했는데 왜 insert가 됐던 거야?

| 질문 | 답변 요약 |
| --- | --- |
| 단방향 예제에서는 orderRepository.save(order)만 했는데 insert 쿼리가 나갔던 이유는? | 단방향 연관관계에서 우리가 저장한 `Order`가 연관관계의 주인이었고, 외래키 필드(member)가 설정되어 있었기 때문. 주인을 저장했으니 당연히 insert가 수행된 것. |

---

### 💡 8. 양방향인데 왜 member만 저장했어? order는 주인 아닌가?

| 질문 | 답변 요약 |
| --- | --- |
| order가 주인인데, 예제에서는 member만 저장했어. 왜 그래? | 실습 의도는 "Member가 주문을 소유하고 관리한다"는 도메인 모델 표현이었음. `addOrder()` 내부에서 주인인 `Order.member`도 설정해주고, cascade 설정 덕분에 `memberRepository.save()` 하나로 모두 저장됨. |

---

### 💡 9. order까지 저장되지 않으면 DB에서 조회 안 되는 거 아냐?

| 질문 | 답변 요약 |
| --- | --- |
| member만 저장하고 order는 영속성 컨텍스트에만 있으면, 나중에 주문 내역 조회할 수 없는 거 아냐? | ✅ 맞음. order가 실제로 flush/commit되지 않으면 DB에 저장되지 않고, 따라서 나중에 조회해도 데이터가 없음. 주문 내역도 영속화 또는 cascade 저장이 반드시 필요함. |

---

### 💡 10. 영속성 컨텍스트에 있다는 게 DB에 저장됐다는 뜻이야?

| 질문 | 답변 요약 |
| --- | --- |
| save()로 등록됐으면 DB에 저장된 거 아냐? | ❌ 아님. save()는 영속성 컨텍스트에 객체를 등록한 상태일 뿐, 실제로 DB에 insert 되려면 flush 또는 commit이 필요함. 영속성 컨텍스트는 일종의 작업 대기 공간임. |

---

### 💡 11. 연관관계 편의 메서드는 왜 만드는 거야?

| 질문 | 답변 요약 |
| --- | --- |
| 객체끼리 직접 set하거나 생성자로 넣으면 되잖아? 굳이 addOrder 같은 메서드를 왜 만들어? | 양방향 연관관계는 양쪽 필드를 다 설정해줘야 일관성이 유지되는데, 직접 설정하면 한쪽만 누락되기 쉽다. 편의 메서드는 양쪽을 동시에 설정해서 실수도 방지하고, 코드 의미도 명확하게 표현할 수 있다. 특히 실무에선 도메인 중심 설계에서 필수로 쓰인다. |

---

### 💡 12. orders.add(order)는 HashMap의 put()이랑 비슷한 거야?

| 질문 | 답변 요약 |
| --- | --- |
| orders.add(order)가 HashMap의 put()이랑 비슷한 개념이야? | 개념상으론 “컬렉션에 뭔가를 넣는다”는 공통점이 있지만, 실제로는 다름. List의 `add()`는 단순히 요소를 끝에 추가하고 중복을 허용하지만, Map의 `put()`은 key가 중복되면 값을 덮어씀. 기능 차이를 정확히 알고 써야 함. |

---

### 💡 13. Lazy 로딩이란 정확히 무슨 뜻이야?

| 질문 | 답변 요약 |
| --- | --- |
| Lazy 로딩된다는 건 뭐야? | JPA에서 연관 객체를 즉시 로딩하지 않고, 실제 해당 객체를 사용할 때 DB에서 불러오는 전략을 의미함. 성능에 유리하지만, 트랜잭션 범위 밖에서 접근하면 쿼리가 실행되지 않거나 실패할 수 있음. 대표적으로 `member.getOrders()`를 호출하기 전까지 orders에 대한 select 쿼리가 실행되지 않음. |

---

### 💡 14. Lazy 로딩 쓸 때는 @Transactional 꼭 붙여야 해?

| 질문 | 답변 요약 |
| --- | --- |
| Lazy 로딩을 쓸 때는 @Transactional을 반드시 써야 하는 거야? | ✅ 웬만하면 꼭 써야 함. Lazy 로딩은 트랜잭션(영속성 컨텍스트)이 살아있는 동안만 동작하기 때문에, 트랜잭션이 없으면 지연 로딩 시점에 오류가 나거나 빈 결과가 나올 수 있음. 그래서 실습이나 서비스 메서드에서도 반드시 @Transactional로 감싸주는 것이 안전함. |

---

### 💡 15. cascade 설정은 실무에서 어떻게 써야 해?

| 질문 | 답변 요약 |
| --- | --- |
| cascade = CascadeType.PERSIST는 언제 써야 해? 실무에서는 꼭 필요한 거야? | ❌ 실무에서는 무조건 쓰지 않고, 반드시 필요한 관계에서만 신중하게 사용함. 부모 엔티티가 자식 생명주기를 완전히 소유하는 경우(예: 게시글 → 댓글)에는 사용하지만, 대부분은 명시적으로 save()를 호출함. 학습용 예제에서는 흐름 학습 목적이라 적극 사용 가능. |

---

### 💡 16. Hibernate 로그가 두 번씩 나오는 건 왜 그래?

| 질문 | 답변 요약 |
| --- | --- |
| Hibernate 로그가 "DEBUG org.hibernate.SQL"이랑 "Hibernate:" 두 줄로 나와서 헷갈려. 왜 두 개씩 나오는 거야? | 각각 다른 설정에서 나오는 로그라서 그래. `DEBUG org.hibernate.SQL`는 Spring Boot의 로깅 레벨 설정에 따라 찍히는 것이고, `Hibernate:`는 `show-sql: true` 옵션으로 인해 System.out으로 출력되는 SQL임. 둘 다 정상이며, 원한다면 하나만 보이도록 설정 조정 가능함. |

**✅ 정리:**

- `DEBUG org.hibernate.SQL`: Spring logging 출력 (추천)
- `Hibernate:`: show-sql 출력 (System.out, 비권장)
- 깔끔한 로그를 원하면 `show-sql: false`로 끄고, 로깅만 남기는 걸 추천함

---

### 💡 17. 실습미션 참고에 나온 @ToString(exclude), @JsonIgnore는 무슨 뜻이야?

| 질문 | 답변 요약 |
| --- | --- |
| 실습미션 참고에 "@ToString(exclude = ...) 또는 @JsonIgnore 필요할 수 있음"이라고 돼있는데, 우리는 아무 문제 없었잖아? | 맞아! 우리 실습에서는 `@ToString`도 안 썼고, JSON 응답도 없어서 순환참조 문제가 발생하지 않았음. 다만, 실무에서는 양방향 연관관계 시 객체 → 객체 → 객체 식으로 무한루프가 생기기 쉬워서, `@ToString(exclude)`는 콘솔 출력 시, `@JsonIgnore`는 JSON 직렬화 시 순환 방지를 위해 자주 사용됨. |

**✅ 정리:**

- 우리가 문제 없었던 이유: `toString()` 호출도 안 했고, JSON 응답도 안 했기 때문
- 실무에선 자동 출력/직렬화가 많아지므로 방어 코드 필수
- `@ToString(exclude = "필드")`: 객체 → 객체 무한출력 방지 (Lombok)
- `@JsonIgnore`: JSON 변환 시 해당 필드를 제외해 무한루프 방지

---

### 🌱 정리 키워드

- 단방향: 한쪽만 참조 (`Order → Member`)
- 양방향: 양쪽 모두 참조 (`Order ↔ Member`)
- 연관관계 주인: 항상 `@ManyToOne` 쪽
- 참조 방향 vs. 주인 개념은 다름
- 테이블 구조는 외래키 기준 → 단방향/양방향과 무관함
- `mappedBy`: 외래키를 가진 쪽 필드명을 지정 (주인이 아님 표시)
- 주인을 정하는 이유: 외래키 조작 기준을 정해 DB 반영의 기준을 확립
- JPA 저장 흐름: `save()` → 영속성 컨텍스트 등록 → `flush` → SQL 생성 → `commit` → DB 반영
- 연관관계 편의 메서드: 양방향 동기화 + 도메인 의미 표현 + 실수 방지
- List vs Map 차이: `add()`는 추가, `put()`은 키-값 저장 및 갱신
- Lazy 로딩: 연관 객체를 실제 사용 시점에 select 쿼리로 불러오는 지연 로딩 방식
- @Transactional: 트랜잭션 경계 설정 + Lazy 로딩 활성화 보장
- CascadeType.PERSIST: 자식까지 자동 저장하고 싶을 때만 신중하게 설정함 (실무에서는 명시 저장 선호)
- Hibernate 로그: `show-sql`과 `logging.level` 설정에 따라 2줄 출력 가능함 (필요 시 선택 조정)
- 순환참조 방지: `@ToString(exclude)`, `@JsonIgnore`로 무한루프 방지 (출력/JSON 변환 시 주의)